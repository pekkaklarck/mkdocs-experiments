{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Robot Framework Manual","text":"<p>This site is a playground for testing Material for Mkdocs features to be used with the Robot Framework Manual that is going to replace the old Robot Framework User Guide. To see the source code, click the edit button on right or go to the pekkaklarck/mkdocs-experiments repository.</p>"},{"location":"#test-or-task","title":"Test or task?","text":"<p>Use the toggle in the header to choose the mode and the following two chapters are changed based on that. The first chapter uses <code>{test}</code> markup that's rendered like <code>test</code> or <code>task</code> based  on the mode. The second chapter and the associated example are replaced altogether.</p> <p>Should we use testtask? TestTasks we shall use!</p> <p>This paragraph is relevant only when doing test automation. We love bugs! </p> <pre><code>*** Test Cases ***\nTesting example\n    Log    Hello, testers!\n</code></pre> <p>This is a paragraph only for the RPA users. We love processes! </p> <pre><code>*** Tasks ***\nRPA example\n    Log    Hello, process automators!\n</code></pre> <p>Everyone needs this paragraph and the following example, but the example is adapted based on the mode.</p> <pre><code>*** Test Cases ***\nExample for all\n    [Documentation]    Only the header changes!\n    Log    Hello, world!\n</code></pre>"},{"location":"#emojis-and-icons","title":"Emojis and icons","text":"<p>Lot of emojis and icons are supported:</p> <ul> <li>Emojis:  </li> <li>Material Design:  </li> <li>FontAwesome:  </li> <li>Octicons:  </li> <li>Simple Icons:  </li> <li>Custom icons:  </li> </ul> <p>Being able to add custom icons is handy, but because Simple Icons already has , having also custom   may not be useful.</p>"},{"location":"#code-snippets","title":"Code snippets","text":"<p>Here's a simple Robot Framework example to get us started! </p> <pre><code>*** Test Case ***\nExample\n    Log    Hello, world!    # (1)!\n</code></pre> <ol> <li>Code annotations work also with  examples! </li> </ol> <p>Did you see the plus sign above? It's a code annotation. Click it!</p> <p>And here's another example using :</p> <pre><code>def example():\n    print('Hello, world!')\n</code></pre> <p>Above examples used fenced code blocks. Here's another Python example using a simple indented code block:</p> <pre><code>def example():\n    print('Hello, world!')    # (1)!\n</code></pre> <ol> <li>Python is configured to be the default language for intended code blocks.</li> </ol>"},{"location":"#links","title":"Links","text":"<p>Standard Markdown syntax:</p> <ul> <li>Link to section on the same page.</li> <li>Link to another page.</li> <li>Link to a section on another page.</li> <li>Link to a different site.</li> <li>Link to a custom target.</li> <li>Link to a custom target having a custom text.</li> <li>Link to somewhere with a title.</li> </ul> <p>Features provided by the autorefs plugin:</p> <ul> <li>Link to header on the same page.</li> <li>Link to a section on another page.</li> <li>Link to a custom anchor.</li> </ul> <p>Features provided by the MagicLink plugin:</p> <ul> <li>URIs like http://robotframework.org are converted to links.</li> <li>Repository URIs like facelessuser/pymdown-extensions are shortened.</li> <li>With a bit of configuration, issues like #42 and users like @pekkaklarck become links as well!</li> </ul> <p>Below we have an image. It uses link-like syntax as well. It also has a custom anchor.</p> <p> </p>"},{"location":"#glossary","title":"Glossary","text":"<p>6251a85a-47d0-11ee-be56-0242ac120002:_:Keyword:&lt;__None__&gt;:5833660d7b60c6176fbcacd1e02d9f9a is a term in our glossary. Term lookup is case-insensitive and takes plural forms into account, so we can refer to a term specified as <code>Library keyword</code> like 6251a85a-47d0-11ee-be56-0242ac120002:_:library keywords:&lt;__None__&gt;:fca06586a99c836c858820b65e3e4f37.</p> <p>Glossary functionality is provided by the mkdocs-ezglossary plugin.</p>"},{"location":"#tabs","title":"Tabs","text":"Tab 1Tab 2LibraryTest Case <p>Tabs can be really useful for us!</p> <p>They are provided by the pymdownx.tabbed plugin.</p> <p>Markdown content.</p> <ul> <li>list item a</li> <li>list item b</li> <li></li> </ul> <pre><code>def greet(name):\n    print(f'Hello, {name}!')\n</code></pre> <pre><code>*** Test Cases ***\nExample\n    Greet    Robot\n</code></pre>"},{"location":"#admonitions","title":"Admonitions","text":"<p>Note</p> <p>All this content is only for experimenting purposes.</p> <pre><code>a = 1 + 2    # superfences!\n</code></pre> <p>Tip</p> <p>\"Normal\" admonitions are provided by the standard admonition plugin.</p> Collapsed! <p>Some initially hidden content here.</p> Success <p>Collapsible admonitions can be initially expendad. They are provided by the pymdownx.details plugin.</p>"},{"location":"#versioning","title":"Versioning","text":"<p>Versioning has been set up using mike as Material for Mkdocs documentation recommends and automated using GitHub Actions.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>This is how versioning works for users viewing the docs and for developers writing them:</p> <ul> <li>When a normal commit is pushed, documentation for the <code>dev</code> version is generated   automatically. New documentation overrides the existing <code>dev</code> docs.</li> <li>When a new stable release tag in format like <code>v0.1</code> or <code>v2.0.1</code> is pushed,   documentation is generated for that release.</li> <li>Release documentation versions use only two components like <code>2.0</code>. If new releases   in same series are created, they override existing documentation for that release.   For example, if there is first release <code>2.0</code> (generated from tag <code>v2.0</code>) and then   <code>2.0.1</code> is released (from tag <code>v2.0.1</code>), the shown <code>2.0</code> docs contain documentation   for version <code>2.0.1</code>.</li> <li>Separate documentation is not generated for pre-releases like <code>2.1rc1</code>. It is   possible to view the <code>dev</code> docs instead.</li> <li><code>latest</code> version is an alias that always points to the docs of the latest release.</li> <li>Opening the documentation root automatically redirects to <code>latest</code>.</li> <li>It is possible to switch between versions using the widget in the page header.</li> <li>Viewing any other documentation version than latest causes a warning to be shown.</li> </ul>"},{"location":"#setting-it-up","title":"Setting it up","text":"<p>This is how versioning has been set up:</p> <ul> <li><code>mike</code> is listed in <code>requirements.txt</code>.</li> <li>Possible old docs from <code>gh-pages</code> root should be removed or moved to a dedicated   directory. Running <code>mike delete --all --push</code> nukes everything, but you need to   make sure your local <code>gh-pages</code> branch is in sync with the origin (and that there   is nothing valuable that should not be removed).</li> <li><code>mkdocs.yml</code> configuration:</li> <li>Versioning is configured under <code>extra</code>.</li> <li><code>mike</code> itself is configured under <code>plugins</code>.</li> <li><code>site_url</code> should, for some reason, contain a trailing <code>/</code>.</li> <li><code>theme/custom_dir</code> sets up the directory containing template for outdated version     warning. That directory is also listed under <code>watch</code>.</li> <li><code>overrides/main.html</code> contains the aforementioned outdated version warning.</li> <li><code>.github/workflows/dev-docs.yml</code> contains configuration for generating <code>dev</code> docs.</li> <li><code>.github/workflows/release-docs.yml</code> contains configuration for generating release docs.</li> <li>The following commands needs to be run once to configure the default version. <p>mike set-default --push --allow-undefined latest</p> </li> <li>To get social cards working when someone refers to the documentation root, copy   related <code>og:xxx</code> (and <code>twitter:xxx</code>) meta tags from <code>latest/index.html</code> to   <code>/index.html</code>. See this project's index.html   for an example.</li> </ul> <p>Warning</p> <p>If workflows for generating <code>dev</code> and release docs are run at the same time, they may conflict when they try to push changes to <code>gh-pages</code>. They should be configured to wait for each others, but that didn't seem to be straightforward. Until that's done, care must be taken not to push release tags until <code>dev</code> doc generation has finished.</p>"},{"location":"glossary/","title":"Glossary","text":"Keyword Keywords are very important for us. 886d7696-137e-4a59-a39d-6f7d311d5bd1:_:Keyword Library keyword Ditto 886d7696-137e-4a59-a39d-6f7d311d5bd1:_:Library keyword"},{"location":"api/","title":"Robot Framework API","text":"<p>Robot Framework's primary, stable public API is provided by the robot.api module. You may sometimes need to import items also from other modules, but that should be relatively rare.</p> <p>Command line entry points that can also be used programmatically are implemented by the following modules:</p> <ul> <li>robot.run entry point for executing tests.</li> <li><code>robot.rebot</code> entry point for post-processing outputs (Rebot).</li> <li><code>robot.libdoc</code> entry point for the Libdoc tool.</li> </ul>"},{"location":"api/nav/","title":"Nav","text":"<ul> <li>API</li> <li> robot<ul> <li> api<ul> <li> interfaces</li> </ul> </li> <li> descriptor</li> <li> run</li> </ul> </li> </ul>"},{"location":"api/robot/","title":"robot","text":""},{"location":"api/robot/#robot","title":"robot","text":"<p>The root of the Robot Framework package.</p> <p>The command line entry points provided by the framework are exposed for programmatic usage as follows:</p> <ul> <li>robot.run: Function to run tests.</li> <li>robot.run_cli: Function to run tests     with command line argument processing.</li> <li><code>robot.rebot</code>: Function to post-process outputs.</li> <li><code>robot.rebot_cli</code>: Function to post-process outputs     with command line argument processing.</li> <li><code>robot.libdoc</code>: Module for library documentation generation.</li> <li><code>robot.testdoc</code>: Module for test case documentation generation.</li> </ul> <p>All the functions above can be imported like <code>from robot import run</code>. Functions and classes provided by the modules need to be imported like <code>from robot.libdoc import libdoc_cli</code>.</p> <p>The functions and modules listed above are considered stable. Other modules in this package are for internal usage and may change without prior notice.</p> <p>Tip</p> <p>More public APIs are exposed by the robot.api package.</p>"},{"location":"api/robot/descriptor/","title":"robot.descriptor","text":""},{"location":"api/robot/descriptor/#robot.descriptor","title":"robot.descriptor","text":"<p>Testing how mkdocstrings handles descriptors.</p> <p>This module is not part of normal Robot Framework code.</p>"},{"location":"api/robot/descriptor/#robot.descriptor.Example","title":"Example","text":"<pre><code>Example(count: int = 1)\n</code></pre> <p>Example using descriptor.</p> Source code in <code>src/robot/descriptor.py</code> <pre><code>def __init__(self, count: int = 1):\n    self.count = count\n</code></pre>"},{"location":"api/robot/descriptor/#robot.descriptor.Example.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>count = count\n</code></pre> <p>Count as a positive integer.</p>"},{"location":"api/robot/run/","title":"robot.run","text":""},{"location":"api/robot/run/#robot.run","title":"robot.run","text":"<p>Module implementing the command line entry point for executing tests.</p> <p>This module can be executed from the command line using the following approaches:</p> <pre><code>python -m robot.run\npython path/to/robot/run.py\n</code></pre> <p>Instead of <code>python</code> it is possible to use also other Python interpreters. This module is also used by the installed <code>robot</code> start-up script.</p> <p>This module also provides robot.run and robot.run_cli functions that can be used programmatically. Other code is for internal usage.</p>"},{"location":"api/robot/run/#robot.run.run_cli","title":"run_cli","text":"<pre><code>run_cli(\n    arguments: list[str] | None = None, exit: bool = True\n)\n</code></pre> <p>Command line execution entry point for running tests.</p> <p>Parameters:</p> Name Type Description Default <code>arguments</code> <code>list[str] | None</code> <p>Command line options and arguments as a list of strings. Defaults to <code>sys.argv[1:]</code> if not given.</p> <code>None</code> <code>exit</code> <code>bool</code> <p>If <code>True</code>, call <code>sys.exit</code> with the return code denoting execution status, otherwise just return the rc.</p> <code>True</code> <p>Entry point used when running tests from the command line, but can also be used by custom scripts that execute tests. Especially useful if the script itself needs to accept same arguments as accepted by Robot Framework, because the script can just pass them forward directly along with the possible default values it sets itself.</p> <p>Example:</p> <pre><code>from robot import run_cli\n\n# Run tests and return the return code.\nrc = run_cli(['--name', 'Example', 'tests.robot'], exit=False)\n\n# Run tests and exit to the system automatically.\nrun_cli(['--name', 'Example', 'tests.robot'])\n</code></pre> <p>See also the robot.run function that allows setting options as keyword arguments like <code>name=\"Example\"</code> and generally has a richer API for programmatic test execution.</p> Source code in <code>src/robot/run.py</code> <pre><code>def run_cli(arguments: 'list[str]|None' = None, exit: bool = True):\n    \"\"\"Command line execution entry point for running tests.\n\n    Parameters:\n        arguments: Command line options and arguments as a list of strings.\n            Defaults to `sys.argv[1:]` if not given.\n        exit: If `True`, call `sys.exit` with the return code denoting\n            execution status, otherwise just return the rc.\n\n    Entry point used when running tests from the command line, but can also\n    be used by custom scripts that execute tests. Especially useful if the\n    script itself needs to accept same arguments as accepted by Robot Framework,\n    because the script can just pass them forward directly along with the\n    possible default values it sets itself.\n\n    Example:\n\n        from robot import run_cli\n\n        # Run tests and return the return code.\n        rc = run_cli(['--name', 'Example', 'tests.robot'], exit=False)\n\n        # Run tests and exit to the system automatically.\n        run_cli(['--name', 'Example', 'tests.robot'])\n\n    See also the [robot.run][robot.run.run] function that allows setting options as keyword\n    arguments like `name=\"Example\"` and generally has a richer API for\n    programmatic test execution.\n    \"\"\"\n    if arguments is None:\n        arguments = sys.argv[1:]\n    return RobotFramework().execute_cli(arguments, exit=exit)\n</code></pre>"},{"location":"api/robot/run/#robot.run.run","title":"run","text":"<pre><code>run(*sources: list[str | Path], **options: dict[str, Any])\n</code></pre> <p>Programmatic entry point for running tests.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>list[str | Path]</code> <p>Paths to test case files/directories to be executed similarly as when running the <code>robot</code> command on the command line.</p> <code>()</code> <code>options</code> <code>dict[str, Any]</code> <p>Options to configure and control execution. Accepted options are mostly same as normal command line options to the <code>robot</code> command. Option names match command line option long names without hyphens so that, for example, <code>--name</code> becomes <code>name</code>.</p> <code>{}</code> <p>Most options that can be given from the command line work. An exception is that options <code>--pythonpath</code>, <code>--argumentfile</code>, <code>--help</code> and <code>--version</code> are not supported.</p> <p>Options that can be given on the command line multiple times can be passed as lists. For example, <code>include=['tag1', 'tag2']</code> is equivalent to <code>--include tag1 --include tag2</code>. If such options are used only once, they can be given also as a single string like <code>include='tag'</code>.</p> <p>Options that accept no value can be given as Booleans. For example, <code>dryrun=True</code> is same as using the <code>--dryrun</code> option.</p> <p>Options that accept string <code>NONE</code> as a special value can also be used with Python <code>None</code>. For example, using <code>log=None</code> is equivalent to <code>--log NONE</code>.</p> <p><code>listener</code>, <code>prerunmodifier</code> and <code>prerebotmodifier</code> options allow passing values as Python objects in addition to module names these command line options support. For example, <code>run('tests', listener=MyListener())</code>.</p> <p>To capture the standard output and error streams, pass an open file or file-like object as special keyword arguments <code>stdout</code> and <code>stderr</code>, respectively.</p> <p>A return code is returned similarly as when running on the command line. Zero means that tests were executed and no test failed, values up to 250 denote the number of failed tests, and values between 251-255 are for other statuses documented in the Robot Framework User Guide.</p> <p>Example:</p> <pre><code>from robot import run\n\nrun('path/to/tests.robot')\nrun('tests.robot', include=['tag1', 'tag2'], splitlog=True)\nwith open('stdout.txt', 'w') as stdout:\n    run('t1.robot', 't2.robot', name='Example', log=None, stdout=stdout)\n</code></pre> <p>Equivalent command line usage:</p> <pre><code>robot path/to/tests.robot\nrobot --include tag1 --include tag2 --splitlog tests.robot\nrobot --name Example --log NONE t1.robot t2.robot &gt; stdout.txt\n</code></pre> Source code in <code>src/robot/run.py</code> <pre><code>def run(*sources: 'list[str|Path]', **options: 'dict[str, Any]'):\n    \"\"\"Programmatic entry point for running tests.\n\n    Parameters:\n        sources: Paths to test case files/directories to be executed similarly\n            as when running the `robot` command on the command line.\n        options: Options to configure and control execution. Accepted\n            options are mostly same as normal command line options to the `robot`\n            command. Option names match command line option long names without\n            hyphens so that, for example, `--name` becomes `name`.\n\n    Most options that can be given from the command line work. An exception\n    is that options `--pythonpath`, `--argumentfile`, `--help` and\n    `--version` are not supported.\n\n    Options that can be given on the command line multiple times can be\n    passed as lists. For example, `include=['tag1', 'tag2']` is equivalent\n    to `--include tag1 --include tag2`. If such options are used only once,\n    they can be given also as a single string like `include='tag'`.\n\n    Options that accept no value can be given as Booleans. For example,\n    `dryrun=True` is same as using the `--dryrun` option.\n\n    Options that accept string `NONE` as a special value can also be used\n    with Python `None`. For example, using `log=None` is equivalent to\n    `--log NONE`.\n\n    `listener`, `prerunmodifier` and `prerebotmodifier` options allow\n    passing values as Python objects in addition to module names these command\n    line options support. For example, `#!py run('tests', listener=MyListener())`.\n\n    To capture the standard output and error streams, pass an open file or\n    file-like object as special keyword arguments `stdout` and `stderr`,\n    respectively.\n\n    A return code is returned similarly as when running on the command line.\n    Zero means that tests were executed and no test failed, values up to 250\n    denote the number of failed tests, and values between 251-255 are for other\n    statuses documented in the Robot Framework User Guide.\n\n    Example:\n\n        from robot import run\n\n        run('path/to/tests.robot')\n        run('tests.robot', include=['tag1', 'tag2'], splitlog=True)\n        with open('stdout.txt', 'w') as stdout:\n            run('t1.robot', 't2.robot', name='Example', log=None, stdout=stdout)\n\n    Equivalent command line usage:\n\n        robot path/to/tests.robot\n        robot --include tag1 --include tag2 --splitlog tests.robot\n        robot --name Example --log NONE t1.robot t2.robot &gt; stdout.txt\n    \"\"\"\n    return RobotFramework().execute(*sources, **options)\n</code></pre>"},{"location":"api/robot/api/","title":"robot.api","text":""},{"location":"api/robot/api/#robot.api","title":"robot.api","text":"<p>:mod:<code>robot.api</code> package exposes the public APIs of Robot Framework.</p> <p>Unless stated otherwise, the APIs exposed in this package are considered stable, and thus safe to use when building external tools on top of Robot Framework. Notice that all parsing APIs were rewritten in Robot Framework 3.2.</p> <p>Currently exposed APIs are:</p> <ul> <li> <p>:mod:<code>.logger</code> module for libraries' logging purposes.</p> </li> <li> <p>:mod:<code>.deco</code> module with decorators libraries can utilize.</p> </li> <li> <p>:mod:<code>.exceptions</code> module containing exceptions that libraries can utilize for   reporting failures and other events. These exceptions can be imported also directly   via :mod:<code>robot.api</code> like <code>from robot.api import SkipExecution</code>.</p> </li> <li> <p>:mod:<code>.interfaces</code> module containing optional base classes that can be used   when creating libraries and other extensions. New in Robot Framework 6.1.</p> </li> <li> <p>:mod:<code>.parsing</code> module exposing the parsing APIs. This module is new in Robot   Framework 4.0. Various parsing related functions and classes were exposed   directly via :mod:<code>robot.api</code> already in Robot Framework 3.2, but they are   effectively deprecated and will be removed in the future.</p> </li> <li> <p>:class:<code>~robot.running.model.TestSuite</code> class for creating executable   test suites programmatically and   :class:<code>~robot.running.builder.builders.TestSuiteBuilder</code> class   for creating such suites based on existing test data on the file system.</p> </li> <li> <p>:class:<code>~robot.model.visitor.SuiteVisitor</code> abstract class for processing testdata   before execution. This can be used as a base for implementing a pre-run   modifier that is taken into use with <code>--prerunmodifier</code> commandline option.</p> </li> <li> <p>:func:<code>~robot.result.resultbuilder.ExecutionResult</code> factory method   for reading execution results from XML output files and   :class:<code>~robot.result.visitor.ResultVisitor</code> abstract class to ease   further processing the results.   :class:<code>~robot.result.visitor.ResultVisitor</code> can also be used as a base   for pre-Rebot modifier that is taken into use with <code>--prerebotmodifier</code>   commandline option.</p> </li> <li> <p>:class:<code>~robot.reporting.resultwriter.ResultWriter</code> class for writing   reports, logs, XML outputs, and XUnit files. Can write results based on   XML outputs on the file system, as well as based on the result objects   returned by the :func:<code>~robot.result.resultbuilder.ExecutionResult</code> or   an executed :class:<code>~robot.running.model.TestSuite</code>.</p> </li> <li> <p>:class:<code>~robot.running.arguments.typeinfo.TypeInfo</code> class for parsing   type hints and converting values based on them. New in Robot Framework 7.0.</p> </li> <li> <p>:class:<code>~robot.conf.languages.Languages</code> and :class:<code>~robot.conf.languages.Language</code>   classes for external tools that need to work with different translations.   The latter is also the base class to use with custom translations.</p> </li> </ul> <p>All of the above classes can be imported like::</p> <pre><code>from robot.api import ClassName\n</code></pre> <p>See documentations of the individual APIs for more details.</p> <p>.. tip:: APIs related to the command line entry points are exposed directly         via the :mod:<code>robot</code> root package.</p>"},{"location":"api/robot/api/interfaces/","title":"robot.api.interfaces","text":""},{"location":"api/robot/api/interfaces/#robot.api.interfaces","title":"robot.api.interfaces","text":"<p>Optional base classes for libraries and other extensions.</p> <p>Module contents:</p> <ul> <li>:class:<code>DynamicLibrary</code> for libraries using the <code>dynamic library API</code>__.</li> <li>:class:<code>HybridLibrary</code> for libraries using the <code>hybrid library API</code>__.</li> <li>:class:<code>ListenerV2</code> for <code>listener interface version 2</code>__.</li> <li>:class:<code>ListenerV3</code> for <code>listener interface version 3</code>__.</li> <li>:class:<code>Parser</code> for <code>custom parsers</code>__. Also   :class:<code>~robot.running.builder.settings.TestDefaults</code> used in <code>Parser</code>   type hints can be imported via this module if needed.</li> <li>Type definitions used by the aforementioned classes.</li> </ul> <p>Main benefit of using these base classes is that editors can provide automatic completion, documentation and type information. Their usage is not required. Notice also that libraries typically use the static API and do not need any base class.</p> <p>.. note:: These classes are not exposed via the top level :mod:<code>robot.api</code>           package and need to imported via :mod:<code>robot.api.interfaces</code>.</p> <p>This module is new in Robot Framework 6.1.</p> <p>__ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#dynamic-library-api __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#hybrid-library-api __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-version-2 __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-version-3 __ http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#parser-interface</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary","title":"DynamicLibrary","text":"<p>               Bases: <code>ABC</code></p> <p>Optional base class for libraries using the dynamic library API.</p> <p>The dynamic library API makes it possible to dynamically specify what keywords a library implements and run them by using :meth:<code>get_keyword_names</code> and :meth:<code>run_keyword</code> methods, respectively. In addition to that it has various optional methods for returning more information about the implemented keywords to Robot Framework.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_names","title":"get_keyword_names  <code>abstractmethod</code>","text":"<pre><code>get_keyword_names() -&gt; Sequence[Name]\n</code></pre> <p>Return names of the keywords this library implements.</p> <p>:return: Keyword names as a list of strings.</p> <p><code>name</code> passed to other methods is always in the same format as returned by this method.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef get_keyword_names(self) -&gt; Sequence[Name]:\n    \"\"\"Return names of the keywords this library implements.\n\n    :return: Keyword names as a list of strings.\n\n    ``name`` passed to other methods is always in the same format as\n    returned by this method.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.run_keyword","title":"run_keyword  <code>abstractmethod</code>","text":"<pre><code>run_keyword(\n    name: Name, args: PositArgs, named: NamedArgs\n) -&gt; Any\n</code></pre> <p>Execute the specified keyword using the given arguments.</p> <p>:param name: Keyword name as a string. :param args: Positional arguments as a list. :param named: Named arguments as a dictionary. :raises: Reporting FAIL or SKIP status. :return: Keyword's return value.</p> <p>Reporting status, logging, returning values, etc. is handled the same way as with the normal static library API.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef run_keyword(self, name: Name, args: PositArgs, named: NamedArgs) -&gt; Any:\n    \"\"\"Execute the specified keyword using the given arguments.\n\n    :param name: Keyword name as a string.\n    :param args: Positional arguments as a list.\n    :param named: Named arguments as a dictionary.\n    :raises: Reporting FAIL or SKIP status.\n    :return: Keyword's return value.\n\n    Reporting status, logging, returning values, etc. is handled the same\n    way as with the normal static library API.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_documentation","title":"get_keyword_documentation","text":"<pre><code>get_keyword_documentation(\n    name: Name,\n) -&gt; Documentation | None\n</code></pre> <p>Optional method to return keyword documentation.</p> <p>The first logical line of keyword documentation is shown in the execution log under the executed keyword. The whole documentation is shown in documentation generated by Libdoc.</p> <p>:param name: Keyword name as a string. :return: Documentation as a string oras <code>None</code> if there is no     documentation.</p> <p>This method is also used to get the overall library documentation as well as documentation related to importing the library. They are got by calling this method with special names <code>__intro__</code> and <code>__init__</code>, respectively.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_documentation(self, name: Name) -&gt; 'Documentation | None':\n    \"\"\"Optional method to return keyword documentation.\n\n    The first logical line of keyword documentation is shown in\n    the execution log under the executed keyword. The whole\n    documentation is shown in documentation generated by Libdoc.\n\n    :param name: Keyword name as a string.\n    :return: Documentation as a string oras ``None`` if there is no\n        documentation.\n\n    This method is also used to get the overall library documentation as\n    well as documentation related to importing the library. They are\n    got by calling this method with special names ``__intro__`` and\n    ``__init__``, respectively.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_arguments","title":"get_keyword_arguments","text":"<pre><code>get_keyword_arguments(name: Name) -&gt; Arguments | None\n</code></pre> <p>Optional method to return keyword's argument specification.</p> <p>Returned information is used during execution for argument validation. In addition to that, arguments are shown in documentation generated by Libdoc.</p> <p>:param name: Keyword name as a string. :return: Argument specification using format explained below.</p> <p>Argument specification defines what arguments the keyword accepts. Returning <code>None</code> means that the keywords accepts any arguments. Accepted arguments are returned as a list using these rules:</p> <ul> <li>Normal arguments are specified as a list of strings like   <code>['arg1', 'arg2']</code>. An empty list denotes that the keyword   accepts no arguments.</li> <li>Varargs must have a <code>*</code> prefix like <code>['*numbers']</code>. There can   be only one varargs, and it must follow normal arguments.</li> <li>Arguments after varargs like <code>['*items', 'arg']</code> are considered   named-only arguments.</li> <li>If keyword does not accept varargs, a lone <code>*</code> can be used   a separator between normal and named-only arguments like   <code>['normal', '*', 'named']</code>.</li> <li>Kwargs must have a <code>**</code>  prefix like <code>['**config']</code>. There can   be only one kwargs, and it must be last.</li> </ul> <p>Both normal arguments and named-only arguments can have default values:</p> <ul> <li>Default values can be embedded to argument names so that they are   separated with the equal sign like <code>name=default</code>. In this case   the default value type is always a string.</li> <li>Alternatively arguments and their default values can be represented   as two-tuples like <code>('name', 'default')</code>. This allows non-string   default values and automatic argument conversion based on them.</li> <li>Arguments without default values can also be specified as tuples   containing just the name like <code>('name',)</code>.</li> <li>With normal arguments, arguments with default values must follow   arguments without them. There is no such restriction with named-only   arguments.</li> </ul> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_arguments(self, name: Name) -&gt; 'Arguments | None':\n    \"\"\"Optional method to return keyword's argument specification.\n\n    Returned information is used during execution for argument validation.\n    In addition to that, arguments are shown in documentation generated\n    by Libdoc.\n\n    :param name: Keyword name as a string.\n    :return: Argument specification using format explained below.\n\n    Argument specification defines what arguments the keyword accepts.\n    Returning ``None`` means that the keywords accepts any arguments.\n    Accepted arguments are returned as a list using these rules:\n\n    - Normal arguments are specified as a list of strings like\n      ``['arg1', 'arg2']``. An empty list denotes that the keyword\n      accepts no arguments.\n    - Varargs must have a ``*`` prefix like ``['*numbers']``. There can\n      be only one varargs, and it must follow normal arguments.\n    - Arguments after varargs like ``['*items', 'arg']`` are considered\n      named-only arguments.\n    - If keyword does not accept varargs, a lone ``*`` can be used\n      a separator between normal and named-only arguments like\n      ``['normal', '*', 'named']``.\n    - Kwargs must have a ``**``  prefix like ``['**config']``. There can\n      be only one kwargs, and it must be last.\n\n    Both normal arguments and named-only arguments can have default values:\n\n    - Default values can be embedded to argument names so that they are\n      separated with the equal sign like ``name=default``. In this case\n      the default value type is always a string.\n    - Alternatively arguments and their default values can be represented\n      as two-tuples like ``('name', 'default')``. This allows non-string\n      default values and automatic argument conversion based on them.\n    - Arguments without default values can also be specified as tuples\n      containing just the name like ``('name',)``.\n    - With normal arguments, arguments with default values must follow\n      arguments without them. There is no such restriction with named-only\n      arguments.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_types","title":"get_keyword_types","text":"<pre><code>get_keyword_types(name: Name) -&gt; TypeHints | None\n</code></pre> <p>Optional method to return keyword's type specification.</p> <p>Type information is used for automatic argument conversion during execution. It is also shown in documentation generated by Libdoc.</p> <p>:param name: Keyword name as a string. :return: Type specification as a dictionary, as a list, or as <code>None</code>     if type information is not known.</p> <p>Type information can be mapped to arguments returned by :meth:<code>get_keyword_names</code> either by names using a dictionary or by position using a list. For example, if a keyword has argument specification <code>['arg', 'second']</code>, it would be possible to return types both like <code>{'arg': str, 'second': int}</code> and <code>[str, int]</code>.</p> <p>Regardless of the approach that is used, it is not necessarily to specify types for all arguments. When using a dictionary, some arguments can be omitted altogether. When using a list, it is possible to use <code>None</code> to mark that a certain argument does not have type information and arguments at the end can be omitted altogether.</p> <p>If is possible to specify that an argument has multiple possible types by using unions like <code>{'arg': Union[int, float]}</code> or tuples like <code>{'arg': (int, float)}</code>.</p> <p>In addition to specifying types using classes, it is also possible to use names or aliases like <code>{'a': 'int', 'b': 'boolean'}</code>. For an up-to-date list of supported types, names and aliases see the User Guide.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_types(self, name: Name) -&gt; 'TypeHints | None':\n    \"\"\"Optional method to return keyword's type specification.\n\n    Type information is used for automatic argument conversion during\n    execution. It is also shown in documentation generated by Libdoc.\n\n    :param name: Keyword name as a string.\n    :return: Type specification as a dictionary, as a list, or as ``None``\n        if type information is not known.\n\n    Type information can be mapped to arguments returned by\n    :meth:`get_keyword_names` either by names using a dictionary or\n    by position using a list. For example, if a keyword has argument\n    specification ``['arg', 'second']``, it would be possible to return\n    types both like ``{'arg': str, 'second': int}`` and ``[str, int]``.\n\n    Regardless of the approach that is used, it is not necessarily to\n    specify types for all arguments. When using a dictionary, some\n    arguments can be omitted altogether. When using a list, it is possible\n    to use ``None`` to mark that a certain argument does not have type\n    information and arguments at the end can be omitted altogether.\n\n    If is possible to specify that an argument has multiple possible types\n    by using unions like ``{'arg': Union[int, float]}`` or tuples like\n    ``{'arg': (int, float)}``.\n\n    In addition to specifying types using classes, it is also possible\n    to use names or aliases like ``{'a': 'int', 'b': 'boolean'}``.\n    For an up-to-date list of supported types, names and aliases see\n    the User Guide.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_tags","title":"get_keyword_tags","text":"<pre><code>get_keyword_tags(name: Name) -&gt; Tags | None\n</code></pre> <p>Optional method to return keyword's tags.</p> <p>Tags are shown in the execution log and in documentation generated by Libdoc. Tags can also be used with various command line options.</p> <p>:param name: Keyword name as a string. :return: Tags as a list of strings or <code>None</code> if there are no tags.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_tags(self, name: Name) -&gt; 'Tags | None':\n    \"\"\"Optional method to return keyword's tags.\n\n    Tags are shown in the execution log and in documentation generated by\n    Libdoc. Tags can also be used with various command line options.\n\n    :param name: Keyword name as a string.\n    :return: Tags as a list of strings or ``None`` if there are no tags.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.DynamicLibrary.get_keyword_source","title":"get_keyword_source","text":"<pre><code>get_keyword_source(name: Name) -&gt; Source | None\n</code></pre> <p>Optional method to return keyword's source path and line number.</p> <p>Source information is used by IDEs to provide navigation from keyword usage to implementation.</p> <p>:param name: Keyword name as a string. :return: Source as a string in format <code>path:lineno</code> or <code>None</code>     if source is not known.</p> <p>The general format to return the source is <code>path:lineno</code> like <code>/example/Lib.py:42</code>. If the line number is not known, it is possible to return only the path. If the keyword is in the same file as the main library class, the path can be omitted and only the line number returned like <code>:42</code>.</p> <p>The source information of the library itself is got automatically from the imported library class. The library source path is used with all keywords that do not return their own path.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def get_keyword_source(self, name: Name) -&gt; 'Source | None':\n    \"\"\"Optional method to return keyword's source path and line number.\n\n    Source information is used by IDEs to provide navigation from\n    keyword usage to implementation.\n\n    :param name: Keyword name as a string.\n    :return: Source as a string in format ``path:lineno`` or ``None``\n        if source is not known.\n\n    The general format to return the source is ``path:lineno`` like\n    ``/example/Lib.py:42``. If the line number is not known, it is\n    possible to return only the path. If the keyword is in the same\n    file as the main library class, the path can be omitted and only\n    the line number returned like ``:42``.\n\n    The source information of the library itself is got automatically from\n    the imported library class. The library source path is used with all\n    keywords that do not return their own path.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.HybridLibrary","title":"HybridLibrary","text":"<p>               Bases: <code>ABC</code></p> <p>Optional base class for libraries using the hybrid library API.</p> <p>Hybrid library API makes it easy to specify what keywords a library implements by using the :meth:<code>get_keyword_names</code> method. After getting keyword names, Robot Framework uses <code>getattr</code> to get the actual keyword methods exactly like it does when using the normal static library API. Keyword name, arguments, documentation, tags, and so on are got directly from the keyword method.</p> <p>It is possible to implement keywords also outside the main library class. In such cases the library needs to have a <code>__getattr__</code> method that returns desired keyword methods.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.HybridLibrary.get_keyword_names","title":"get_keyword_names  <code>abstractmethod</code>","text":"<pre><code>get_keyword_names() -&gt; Sequence[Name]\n</code></pre> <p>Return names of the implemented keyword methods as a list or strings.</p> <p>Returned names must match names of the implemented keyword methods.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef get_keyword_names(self) -&gt; Sequence[Name]:\n    \"\"\"Return names of the implemented keyword methods as a list or strings.\n\n    Returned names must match names of the implemented keyword methods.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.StartSuiteAttributes","title":"StartSuiteAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>start_suite</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.EndSuiteAttributes","title":"EndSuiteAttributes","text":"<p>               Bases: <code>StartSuiteAttributes</code></p> <p>Attributes passed to listener v2 <code>end_suite</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.StartTestAttributes","title":"StartTestAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>start_test</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.EndTestAttributes","title":"EndTestAttributes","text":"<p>               Bases: <code>StartTestAttributes</code></p> <p>Attributes passed to listener v2 <code>end_test</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.OptionalKeywordAttributes","title":"OptionalKeywordAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Extra attributes passed to listener v2 <code>start/end_keyword</code> methods.</p> <p>These attributes are included with control structures. For example, with IF structures attributes include <code>condition</code>.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.StartKeywordAttributes","title":"StartKeywordAttributes","text":"<p>               Bases: <code>OptionalKeywordAttributes</code></p> <p>Attributes passed to listener v2 <code>start_keyword</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.EndKeywordAttributes","title":"EndKeywordAttributes","text":"<p>               Bases: <code>StartKeywordAttributes</code></p> <p>Attributes passed to listener v2 <code>end_keyword</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.MessageAttributes","title":"MessageAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>log_message</code> and <code>messages</code> methods.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.LibraryAttributes","title":"LibraryAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>library_import</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ResourceAttributes","title":"ResourceAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>resource_import</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.VariablesAttributes","title":"VariablesAttributes","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attributes passed to listener v2 <code>variables_import</code> method.</p> <p>See the User Guide for more information.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2","title":"ListenerV2","text":"<p>Optional base class for listeners using the listener API version 2.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.start_suite","title":"start_suite","text":"<pre><code>start_suite(name: str, attributes: StartSuiteAttributes)\n</code></pre> <p>Called when a suite starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_suite(self, name: str, attributes: StartSuiteAttributes):\n    \"\"\"Called when a suite starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.end_suite","title":"end_suite","text":"<pre><code>end_suite(name: str, attributes: EndSuiteAttributes)\n</code></pre> <p>Called when a suite end.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_suite(self, name: str, attributes: EndSuiteAttributes):\n    \"\"\"Called when a suite end.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.start_test","title":"start_test","text":"<pre><code>start_test(name: str, attributes: StartTestAttributes)\n</code></pre> <p>Called when a test or task starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_test(self, name: str, attributes: StartTestAttributes):\n    \"\"\"Called when a test or task starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.end_test","title":"end_test","text":"<pre><code>end_test(name: str, attributes: EndTestAttributes)\n</code></pre> <p>Called when a test or task ends.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_test(self, name: str, attributes: EndTestAttributes):\n    \"\"\"Called when a test or task ends.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(\n    name: str, attributes: StartKeywordAttributes\n)\n</code></pre> <p>Called when a keyword or a control structure like IF starts.</p> <p>The type of the started item is in <code>attributes['type']</code>. Control structures can contain extra attributes that are only relevant to them.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_keyword(self, name: str, attributes: StartKeywordAttributes):\n    \"\"\"Called when a keyword or a control structure like IF starts.\n\n    The type of the started item is in ``attributes['type']``. Control\n    structures can contain extra attributes that are only relevant to them.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(name: str, attributes: EndKeywordAttributes)\n</code></pre> <p>Called when a keyword or a control structure like IF ends.</p> <p>The type of the started item is in <code>attributes['type']</code>. Control structures can contain extra attributes that are only relevant to them.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_keyword(self, name: str, attributes: EndKeywordAttributes):\n    \"\"\"Called when a keyword or a control structure like IF ends.\n\n    The type of the started item is in ``attributes['type']``. Control\n    structures can contain extra attributes that are only relevant to them.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.log_message","title":"log_message","text":"<pre><code>log_message(message: MessageAttributes)\n</code></pre> <p>Called when a normal log message are emitted.</p> <p>The messages are typically logged by keywords, but also the framework itself logs some messages. These messages end up to output.xml and log.html.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_message(self, message: MessageAttributes):\n    \"\"\"Called when a normal log message are emitted.\n\n    The messages are typically logged by keywords, but also the framework\n    itself logs some messages. These messages end up to output.xml and\n    log.html.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.message","title":"message","text":"<pre><code>message(message: MessageAttributes)\n</code></pre> <p>Called when framework's internal messages are emitted.</p> <p>Only logged by the framework itself. These messages end up to the syslog if it is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def message(self, message: MessageAttributes):\n    \"\"\"Called when framework's internal messages are emitted.\n\n    Only logged by the framework itself. These messages end up to the syslog\n    if it is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.library_import","title":"library_import","text":"<pre><code>library_import(name: str, attributes: LibraryAttributes)\n</code></pre> <p>Called after a library has been imported.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def library_import(self, name: str, attributes: LibraryAttributes):\n    \"\"\"Called after a library has been imported.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.resource_import","title":"resource_import","text":"<pre><code>resource_import(name: str, attributes: ResourceAttributes)\n</code></pre> <p>Called after a resource file has been imported.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def resource_import(self, name: str, attributes: ResourceAttributes):\n    \"\"\"Called after a resource file has been imported.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.variables_import","title":"variables_import","text":"<pre><code>variables_import(\n    name: str, attributes: VariablesAttributes\n)\n</code></pre> <p>Called after a variable file has been imported.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def variables_import(self, name: str, attributes: VariablesAttributes):\n    \"\"\"Called after a variable file has been imported.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.output_file","title":"output_file","text":"<pre><code>output_file(path: str)\n</code></pre> <p>Called after the output file has been created.</p> <p><code>path</code> is an absolute path to the output file or a string <code>None</code> if creating the output file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def output_file(self, path: str):\n    \"\"\"Called after the output file has been created.\n\n    ``path`` is an absolute path to the output file or\n    a string ``None`` if creating the output file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.log_file","title":"log_file","text":"<pre><code>log_file(path: str)\n</code></pre> <p>Called after the log file has been created.</p> <p><code>path</code> is an absolute path to the log file. Not called if creating the log file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_file(self, path: str):\n    \"\"\"Called after the log file has been created.\n\n    ``path`` is an absolute path to the log file.\n    Not called if creating the log file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.report_file","title":"report_file","text":"<pre><code>report_file(path: str)\n</code></pre> <p>Called after the report file has been created.</p> <p><code>path</code> is an absolute path to the report file. Not called if creating the report file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def report_file(self, path: str):\n    \"\"\"Called after the report file has been created.\n\n    ``path`` is an absolute path to the report file.\n    Not called if creating the report file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.xunit_file","title":"xunit_file","text":"<pre><code>xunit_file(path: str)\n</code></pre> <p>Called after the xunit compatible output file has been created.</p> <p><code>path</code> is an absolute path to the xunit file. Only called if creating the xunit file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def xunit_file(self, path: str):\n    \"\"\"Called after the xunit compatible output file has been created.\n\n    ``path`` is an absolute path to the xunit file.\n    Only called if creating the xunit file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.debug_file","title":"debug_file","text":"<pre><code>debug_file(path: str)\n</code></pre> <p>Called after the debug file has been created.</p> <p><code>path</code> is an absolute path to the debug file. Only called if creating the debug file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def debug_file(self, path: str):\n    \"\"\"Called after the debug file has been created.\n\n    ``path`` is an absolute path to the debug file.\n    Only called if creating the debug file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV2.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Called when the whole execution ends.</p> <p>With library listeners called when the library goes out of scope.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def close(self):\n    \"\"\"Called when the whole execution ends.\n\n    With library listeners called when the library goes out of scope.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3","title":"ListenerV3","text":"<p>Optional base class for listeners using the listener API version 3.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_suite","title":"start_suite","text":"<pre><code>start_suite(data: TestSuite, result: TestSuite)\n</code></pre> <p>Called when a suite starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_suite(self, data: running.TestSuite, result: result.TestSuite):\n    \"\"\"Called when a suite starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_suite","title":"end_suite","text":"<pre><code>end_suite(data: TestSuite, result: TestSuite)\n</code></pre> <p>Called when a suite ends.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_suite(self, data: running.TestSuite, result: result.TestSuite):\n    \"\"\"Called when a suite ends.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_test","title":"start_test","text":"<pre><code>start_test(data: TestCase, result: TestCase)\n</code></pre> <p>Called when a test or task starts.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_test(self, data: running.TestCase, result: result.TestCase):\n    \"\"\"Called when a test or task starts.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_test","title":"end_test","text":"<pre><code>end_test(data: TestCase, result: TestCase)\n</code></pre> <p>Called when a test or tasks ends.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_test(self, data: running.TestCase, result: result.TestCase):\n    \"\"\"Called when a test or tasks ends.\"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_keyword","title":"start_keyword","text":"<pre><code>start_keyword(data: Keyword, result: Keyword)\n</code></pre> <p>Called when a keyword starts by default.</p> <p>This method is called, by default, with user keywords, library keywords and when a keyword call is invalid. It is not called, however, if a more specific :meth:<code>start_user_keyword</code>, :meth:<code>start_library_keyword</code> or :meth:<code>start_invalid_keyword</code> method is implemented.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_keyword(self, data: running.Keyword, result: result.Keyword):\n    \"\"\"Called when a keyword starts by default.\n\n    This method is called, by default, with user keywords, library keywords\n    and when a keyword call is invalid. It is not called, however, if a more\n    specific :meth:`start_user_keyword`, :meth:`start_library_keyword` or\n    :meth:`start_invalid_keyword` method is implemented.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_keyword","title":"end_keyword","text":"<pre><code>end_keyword(data: Keyword, result: Keyword)\n</code></pre> <p>Called when a keyword ends by default.</p> <p>This method is called, by default, with user keywords, library keywords and when a keyword call is invalid. It is not called, however, if a more specific :meth:<code>end_user_keyword</code>, :meth:<code>end_library_keyword</code> or :meth:<code>end_invalid_keyword</code> method is implemented.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_keyword(self, data: running.Keyword, result: result.Keyword):\n    \"\"\"Called when a keyword ends by default.\n\n    This method is called, by default, with user keywords, library keywords\n    and when a keyword call is invalid. It is not called, however, if a more\n    specific :meth:`end_user_keyword`, :meth:`end_library_keyword` or\n    :meth:`end_invalid_keyword` method is implemented.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_user_keyword","title":"start_user_keyword","text":"<pre><code>start_user_keyword(\n    data: Keyword,\n    implementation: UserKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a user keyword starts.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_user_keyword(self, data: running.Keyword,\n                       implementation: running.UserKeyword,\n                       result: result.Keyword):\n    \"\"\"Called when a user keyword starts.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_user_keyword","title":"end_user_keyword","text":"<pre><code>end_user_keyword(\n    data: Keyword,\n    implementation: UserKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a user keyword ends.</p> <p>The default implementation calls :meth:<code>end_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_user_keyword(self, data: running.Keyword,\n                     implementation: running.UserKeyword,\n                     result: result.Keyword):\n    \"\"\"Called when a user keyword ends.\n\n    The default implementation calls :meth:`end_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_library_keyword","title":"start_library_keyword","text":"<pre><code>start_library_keyword(\n    data: Keyword,\n    implementation: LibraryKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a library keyword starts.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_library_keyword(self, data: running.Keyword,\n                          implementation: running.LibraryKeyword,\n                          result: result.Keyword):\n    \"\"\"Called when a library keyword starts.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_library_keyword","title":"end_library_keyword","text":"<pre><code>end_library_keyword(\n    data: Keyword,\n    implementation: LibraryKeyword,\n    result: Keyword,\n)\n</code></pre> <p>Called when a library keyword ends.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_library_keyword(self, data: running.Keyword,\n                        implementation: running.LibraryKeyword,\n                        result: result.Keyword):\n    \"\"\"Called when a library keyword ends.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_invalid_keyword","title":"start_invalid_keyword","text":"<pre><code>start_invalid_keyword(\n    data: Keyword,\n    implementation: KeywordImplementation,\n    result: Keyword,\n)\n</code></pre> <p>Called when an invalid keyword call starts.</p> <p>Keyword may not have been found, there could have been multiple matches, or the keyword call itself could have been invalid.</p> <p>The default implementation calls :meth:<code>start_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_invalid_keyword(self, data: running.Keyword,\n                          implementation: running.KeywordImplementation,\n                          result: result.Keyword):\n    \"\"\"Called when an invalid keyword call starts.\n\n    Keyword may not have been found, there could have been multiple matches,\n    or the keyword call itself could have been invalid.\n\n    The default implementation calls :meth:`start_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_invalid_keyword","title":"end_invalid_keyword","text":"<pre><code>end_invalid_keyword(\n    data: Keyword,\n    implementation: KeywordImplementation,\n    result: Keyword,\n)\n</code></pre> <p>Called when an invalid keyword call ends.</p> <p>Keyword may not have been found, there could have been multiple matches, or the keyword call itself could have been invalid.</p> <p>The default implementation calls :meth:<code>end_keyword</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_invalid_keyword(self, data: running.Keyword,\n                        implementation: running.KeywordImplementation,\n                        result: result.Keyword):\n    \"\"\"Called when an invalid keyword call ends.\n\n    Keyword may not have been found, there could have been multiple matches,\n    or the keyword call itself could have been invalid.\n\n    The default implementation calls :meth:`end_keyword`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_keyword(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_for","title":"start_for","text":"<pre><code>start_for(data: For, result: For)\n</code></pre> <p>Called when a FOR loop starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_for(self, data: running.For, result: result.For):\n    \"\"\"Called when a FOR loop starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_for","title":"end_for","text":"<pre><code>end_for(data: For, result: For)\n</code></pre> <p>Called when a FOR loop ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_for(self, data: running.For, result: result.For):\n    \"\"\"Called when a FOR loop ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_for_iteration","title":"start_for_iteration","text":"<pre><code>start_for_iteration(\n    data: ForIteration, result: ForIteration\n)\n</code></pre> <p>Called when a FOR loop iteration starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_for_iteration(self, data: running.ForIteration,\n                        result: result.ForIteration):\n    \"\"\"Called when a FOR loop iteration starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_for_iteration","title":"end_for_iteration","text":"<pre><code>end_for_iteration(data: ForIteration, result: ForIteration)\n</code></pre> <p>Called when a FOR loop iteration ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_for_iteration(self, data: running.ForIteration,\n                      result: result.ForIteration):\n    \"\"\"Called when a FOR loop iteration ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_while","title":"start_while","text":"<pre><code>start_while(data: While, result: While)\n</code></pre> <p>Called when a WHILE loop starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_while(self, data: running.While, result: result.While):\n    \"\"\"Called when a WHILE loop starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_while","title":"end_while","text":"<pre><code>end_while(data: While, result: While)\n</code></pre> <p>Called when a WHILE loop ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_while(self, data: running.While, result: result.While):\n    \"\"\"Called when a WHILE loop ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_while_iteration","title":"start_while_iteration","text":"<pre><code>start_while_iteration(\n    data: WhileIteration, result: WhileIteration\n)\n</code></pre> <p>Called when a WHILE loop iteration starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_while_iteration(self, data: running.WhileIteration,\n                          result: result.WhileIteration):\n    \"\"\"Called when a WHILE loop iteration starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_while_iteration","title":"end_while_iteration","text":"<pre><code>end_while_iteration(\n    data: WhileIteration, result: WhileIteration\n)\n</code></pre> <p>Called when a WHILE loop iteration ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_while_iteration(self, data: running.WhileIteration,\n                        result: result.WhileIteration):\n    \"\"\"Called when a WHILE loop iteration ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_if","title":"start_if","text":"<pre><code>start_if(data: If, result: If)\n</code></pre> <p>Called when an IF/ELSE structure starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_if(self, data: running.If, result: result.If):\n    \"\"\"Called when an IF/ELSE structure starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_if","title":"end_if","text":"<pre><code>end_if(data: If, result: If)\n</code></pre> <p>Called when an IF/ELSE structure ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_if(self, data: running.If, result: result.If):\n    \"\"\"Called when an IF/ELSE structure ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_if_branch","title":"start_if_branch","text":"<pre><code>start_if_branch(data: IfBranch, result: IfBranch)\n</code></pre> <p>Called when an individual IF/ELSE branch starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_if_branch(self, data: running.IfBranch, result: result.IfBranch):\n    \"\"\"Called when an individual IF/ELSE branch starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_if_branch","title":"end_if_branch","text":"<pre><code>end_if_branch(data: IfBranch, result: IfBranch)\n</code></pre> <p>Called when an individual IF/ELSE branch ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_if_branch(self, data: running.IfBranch, result: result.IfBranch):\n    \"\"\"Called when an individual IF/ELSE branch ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_try","title":"start_try","text":"<pre><code>start_try(data: Try, result: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_try(self, data: running.Try, result: result.Try):\n    \"\"\"Called when a TRY/EXCEPT structure starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_try","title":"end_try","text":"<pre><code>end_try(data: Try, result: Try)\n</code></pre> <p>Called when a TRY/EXCEPT structure ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_try(self, data: running.Try, result: result.Try):\n    \"\"\"Called when a TRY/EXCEPT structure ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_try_branch","title":"start_try_branch","text":"<pre><code>start_try_branch(data: TryBranch, result: TryBranch)\n</code></pre> <p>Called when an individual TRY/EXCEPT branch starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_try_branch(self, data: running.TryBranch, result: result.TryBranch):\n    \"\"\"Called when an individual TRY/EXCEPT branch starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_try_branch","title":"end_try_branch","text":"<pre><code>end_try_branch(data: TryBranch, result: TryBranch)\n</code></pre> <p>Called when an individual TRY/EXCEPT branch ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_try_branch(self, data: running.TryBranch, result: result.TryBranch):\n    \"\"\"Called when an individual TRY/EXCEPT branch ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_var","title":"start_var","text":"<pre><code>start_var(data: Var, result: Var)\n</code></pre> <p>Called when VAR starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_var(self, data: running.Var, result: result.Var):\n    \"\"\"Called when VAR starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_var","title":"end_var","text":"<pre><code>end_var(data: Var, result: Var)\n</code></pre> <p>Called when VAR ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_var(self, data: running.Var, result: result.Var):\n    \"\"\"Called when VAR ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_break","title":"start_break","text":"<pre><code>start_break(data: Break, result: Break)\n</code></pre> <p>Called when BREAK starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_break(self, data: running.Break, result: result.Break):\n    \"\"\"Called when BREAK starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_break","title":"end_break","text":"<pre><code>end_break(data: Break, result: Break)\n</code></pre> <p>Called when BREAK ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_break(self, data: running.Break, result: result.Break):\n    \"\"\"Called when BREAK ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_continue","title":"start_continue","text":"<pre><code>start_continue(data: Continue, result: Continue)\n</code></pre> <p>Called when CONTINUE starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_continue(self, data: running.Continue, result: result.Continue):\n    \"\"\"Called when CONTINUE starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_continue","title":"end_continue","text":"<pre><code>end_continue(data: Continue, result: Continue)\n</code></pre> <p>Called when CONTINUE ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_continue(self, data: running.Continue, result: result.Continue):\n    \"\"\"Called when CONTINUE ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_return","title":"start_return","text":"<pre><code>start_return(data: Return, result: Return)\n</code></pre> <p>Called when RETURN starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_return(self, data: running.Return, result: result.Return):\n    \"\"\"Called when RETURN starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_return","title":"end_return","text":"<pre><code>end_return(data: Return, result: Return)\n</code></pre> <p>Called when RETURN ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_return(self, data: running.Return, result: result.Return):\n    \"\"\"Called when RETURN ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_error","title":"start_error","text":"<pre><code>start_error(data: Error, result: Error)\n</code></pre> <p>Called when encountered invalid syntax starts.</p> <p>The default implementation calls :meth:<code>start_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_error(self, data: running.Error, result: result.Error):\n    \"\"\"Called when encountered invalid syntax starts.\n\n    The default implementation calls :meth:`start_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.start_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_error","title":"end_error","text":"<pre><code>end_error(data: Error, result: Error)\n</code></pre> <p>Called when encountered invalid syntax ends.</p> <p>The default implementation calls :meth:<code>end_body_item</code>.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_error(self, data: running.Error, result: result.Error):\n    \"\"\"Called when encountered invalid syntax ends.\n\n    The default implementation calls :meth:`end_body_item`.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    self.end_body_item(data, result)\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.start_body_item","title":"start_body_item","text":"<pre><code>start_body_item(data, result)\n</code></pre> <p>Called by default when a keyword or a control structure starts.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def start_body_item(self, data, result):\n    \"\"\"Called by default when a keyword or a control structure starts.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.end_body_item","title":"end_body_item","text":"<pre><code>end_body_item(data, result)\n</code></pre> <p>Called by default when a keyword or a control structure ends.</p> <p>New in Robot Framework 7.0.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def end_body_item(self, data, result):\n    \"\"\"Called by default when a keyword or a control structure ends.\n\n    New in Robot Framework 7.0.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.log_message","title":"log_message","text":"<pre><code>log_message(message: Message)\n</code></pre> <p>Called when a normal log message are emitted.</p> <p>The messages are typically logged by keywords, but also the framework itself logs some messages. These messages end up to output.xml and log.html.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_message(self, message: Message):\n    \"\"\"Called when a normal log message are emitted.\n\n    The messages are typically logged by keywords, but also the framework\n    itself logs some messages. These messages end up to output.xml and\n    log.html.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.message","title":"message","text":"<pre><code>message(message: Message)\n</code></pre> <p>Called when framework's internal messages are emitted.</p> <p>Only logged by the framework itself. These messages end up to the syslog if it is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def message(self, message: Message):\n    \"\"\"Called when framework's internal messages are emitted.\n\n    Only logged by the framework itself. These messages end up to the syslog\n    if it is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.library_import","title":"library_import","text":"<pre><code>library_import(library: TestLibrary, importer: Import)\n</code></pre> <p>Called after a library has been imported.</p> <p><code>library</code> represents the imported library. It can be inspected and also modified. <code>importer</code> contains information about the location where the library was imported.</p> <p>New in Robot Framework 7.1.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def library_import(self, library: running.TestLibrary, importer: running.Import):\n    \"\"\"Called after a library has been imported.\n\n    ``library`` represents the imported library. It can be inspected and\n    also modified. ``importer`` contains information about the location where\n    the library was imported.\n\n    New in Robot Framework 7.1.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.resource_import","title":"resource_import","text":"<pre><code>resource_import(resource: ResourceFile, importer: Import)\n</code></pre> <p>Called after a resource file has been imported.</p> <p><code>resource</code> represents the imported resource file. It can be inspected and also modified. <code>importer</code> contains information about the location where the resource was imported.</p> <p>New in Robot Framework 7.1.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def resource_import(self, resource: running.ResourceFile, importer: running.Import):\n    \"\"\"Called after a resource file has been imported.\n\n    ``resource`` represents the imported resource file. It can be inspected and\n    also modified. ``importer`` contains information about the location where\n    the resource was imported.\n\n    New in Robot Framework 7.1.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.variables_import","title":"variables_import","text":"<pre><code>variables_import(attrs: dict, importer: Import)\n</code></pre> <p>Called after a variable file has been imported.</p> <p><code>attrs</code> contains information about the imported variable file. It can be inspected, but modifications to it have no effect. `importer`` contains information about the location where the variable file was imported.</p> <p>New in Robot Framework 7.1. This method will be changed in the future so that the <code>attrs</code> dictionary is replaced with an object representing the imported variable file.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def variables_import(self, attrs: dict, importer: running.Import):\n    \"\"\"Called after a variable file has been imported.\n\n    ``attrs`` contains information about the imported variable file. It can be\n    inspected, but modifications to it have no effect. `importer`` contains\n    information about the location where the variable file was imported.\n\n    New in Robot Framework 7.1. This method will be changed in the future\n    so that the ``attrs`` dictionary is replaced with an object representing\n    the imported variable file.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.output_file","title":"output_file","text":"<pre><code>output_file(path: Path | None)\n</code></pre> <p>Called after the output file has been created.</p> <p><code>path</code> is an absolute path to the output file or <code>None</code> if creating the output file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def output_file(self, path: 'Path | None'):\n    \"\"\"Called after the output file has been created.\n\n    ``path`` is an absolute path to the output file or\n    ``None`` if creating the output file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.log_file","title":"log_file","text":"<pre><code>log_file(path: Path)\n</code></pre> <p>Called after the log file has been created.</p> <p><code>path</code> is an absolute path to the log file. Not called if creating the log file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def log_file(self, path: Path):\n    \"\"\"Called after the log file has been created.\n\n    ``path`` is an absolute path to the log file.\n    Not called if creating the log file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.report_file","title":"report_file","text":"<pre><code>report_file(path: Path)\n</code></pre> <p>Called after the report file has been created.</p> <p><code>path</code> is an absolute path to the report file. Not called if creating the report file is disabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def report_file(self, path: Path):\n    \"\"\"Called after the report file has been created.\n\n    ``path`` is an absolute path to the report file.\n    Not called if creating the report file is disabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.xunit_file","title":"xunit_file","text":"<pre><code>xunit_file(path: Path)\n</code></pre> <p>Called after the xunit compatible output file has been created.</p> <p><code>path</code> is an absolute path to the xunit file. Only called if creating the xunit file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def xunit_file(self, path: Path):\n    \"\"\"Called after the xunit compatible output file has been created.\n\n    ``path`` is an absolute path to the xunit file.\n    Only called if creating the xunit file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.debug_file","title":"debug_file","text":"<pre><code>debug_file(path: Path)\n</code></pre> <p>Called after the debug file has been created.</p> <p><code>path</code> is an absolute path to the debug file. Only called if creating the debug file is enabled.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def debug_file(self, path: Path):\n    \"\"\"Called after the debug file has been created.\n\n    ``path`` is an absolute path to the debug file.\n    Only called if creating the debug file is enabled.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.ListenerV3.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Called when the whole execution ends.</p> <p>With library listeners called when the library goes out of scope.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def close(self):\n    \"\"\"Called when the whole execution ends.\n\n    With library listeners called when the library goes out of scope.\n    \"\"\"\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.Parser","title":"Parser","text":"<p>               Bases: <code>ABC</code></p> <p>Optional base class for custom parsers.</p> <p>Parsers do not need to explicitly extend this class and in simple cases it is possible to implement them as modules. Regardless how a parser is implemented, it must have :attr:<code>extension</code> attribute and :meth:<code>parse</code> method. The :meth:<code>parse_init</code> method is optional and only needed if a parser supports parsing suite initialization files.</p> <p>The mandatory :attr:<code>extension</code> attribute specifies what file extension or extensions a parser supports. It can be set either as a class or instance attribute, and it can be either a string or a sequence of strings. The attribute can also be named <code>EXTENSION</code>, which typically works better when a parser is implemented as a module.</p> <p>Example::</p> <pre><code>from pathlib import Path\nfrom robot.api import TestSuite\nfrom robot.api.interfaces import Parser, TestDefaults\n\n\nclass ExampleParser(Parser):\n    extension = '.example'\n\n    def parse(self, source: Path, defaults: TestDefaults) -&gt; TestSuite:\n        suite = TestSuite(TestSuite.name_from_source(source), source=source)\n        # parse the source file and add tests to the created suite\n        return suite\n</code></pre> <p>The support for custom parsers is new in Robot Framework 6.1.</p>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.Parser.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(source: Path, defaults: TestDefaults) -&gt; TestSuite\n</code></pre> <p>Mandatory method for parsing suite files.</p> <p>:param source: Path to the file to parse. :param defaults: Default values set for test in init files.</p> <p>The <code>defaults</code> argument is optional. It is possible to implement this method also so that it accepts only <code>source</code>.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>@abstractmethod\ndef parse(self, source: Path, defaults: TestDefaults) -&gt; TestSuite:\n    \"\"\"Mandatory method for parsing suite files.\n\n    :param source: Path to the file to parse.\n    :param defaults: Default values set for test in init files.\n\n    The ``defaults`` argument is optional. It is possible to implement\n    this method also so that it accepts only ``source``.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/robot/api/interfaces/#robot.api.interfaces.Parser.parse_init","title":"parse_init","text":"<pre><code>parse_init(\n    source: Path, defaults: TestDefaults\n) -&gt; TestSuite\n</code></pre> <p>Optional method for parsing suite initialization files.</p> <p>:param source: Path to the file to parse. :param defaults: Default values to used with tests in child suites.</p> <p>The <code>defaults</code> argument is optional. It is possible to implement this method also so that it accepts only <code>source</code>.</p> <p>If this method is not implemented, possible initialization files cause an error.</p> Source code in <code>src/robot/api/interfaces.py</code> <pre><code>def parse_init(self, source: Path, defaults: TestDefaults) -&gt; TestSuite:\n    \"\"\"Optional method for parsing suite initialization files.\n\n    :param source: Path to the file to parse.\n    :param defaults: Default values to used with tests in child suites.\n\n    The ``defaults`` argument is optional. It is possible to implement\n    this method also so that it accepts only ``source``.\n\n    If this method is not implemented, possible initialization files cause\n    an error.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"extending/","title":"Extending Robot Framework","text":"<p>Introduction to the extending section.</p>"},{"location":"extending/libraries/","title":"Creating libraries","text":"<p>Considering how important this topic is, this page is pretty empty.</p>"},{"location":"libraries/","title":"Standard libraries","text":"<p>Standard libraries are distributed with Robot Framework as part of a normal installation. Some of them have external dependencies that need to be installed before they can be used, though. See library documentations themselves for more details about possible dependencies and libraries in general.</p>"},{"location":"libraries/#library-documentation","title":"Library documentation","text":"<p>The following table contains links to standard library documentation in external files.</p> Library Description BuiltIn Contains generic often needed keywords. Imported automatically and thus always available. Collections Contains keywords for handling lists and dictionaries. DateTime Supports creating and verifying date and time values as well as calculations between them. Dialogs Supports pausing the test execution and getting input from users. OperatingSystem Enables performing various operating system related tasks. Process Supports executing processes in the system. Remote Part of the remote library interface. Does not have any keywords of its own. Screenshot Provides keywords to capture and store screenshots of the desktop. String Library for manipulating strings and verifying their contents. Telnet Supports connecting to Telnet servers and executing commands on the opened connections. XML Library for verifying and modifying XML documents."},{"location":"libraries/#spec-files","title":"Spec files","text":"<p>Standard library spec files are hosted here as well. They contain library information in JSON format and can be used by external tools such as editors.</p> <ul> <li>BuiltIn </li> <li>Collections </li> <li>DateTime </li> <li>Dialogs </li> <li>OperatingSystem</li> <li>Process </li> <li>Screenshot </li> <li>String </li> <li>Telnet </li> <li>XML </li> </ul>"},{"location":"using/","title":"Using Robot Framework","text":"<p>Introduction to the usage section. We have another references to the 6251a85a-47d0-11ee-be56-0242ac120002:_:keyword:&lt;__None__&gt;:76cae5e906eb2cc33eea68e59d51dd2e term here. We are be talking about testtasks based on the test/task mode.</p> <pre><code>*** Test Cases ***\nExample\n    Log   Header should be set based on the test/task mode.\n</code></pre>"},{"location":"using/data/","title":"Input data","text":"<ul> <li>Input data syntax</li> <li>Files and directories</li> <li>Input data sections</li> <li>Supported file formats</li> <li>Rules for parsing the data</li> <li>Localization</li> </ul>"},{"location":"using/data/#input-data-syntax","title":"Input data syntax","text":"<p>This section covers Robot Framework's overall input data syntax. Input data being  - test data to support test cases - initial imported data, separated from tasks script code, for Robotic Process Automation (RPA) script use</p>"},{"location":"using/data/#files-and-directories","title":"Files and directories","text":"<p>The hierarchical structure for arranging test cases/RPA tasks is designed as follows:</p> <ul> <li>Test cases/RPA tasks are created in <code>suite files</code>.</li> <li>A test case file automatically creates a <code>test suite</code> containing   the test cases/tasks in that file.</li> <li>An RPA task file automatically creates a <code>task suite</code>containing   the tasks in that file.</li> <li>A directory containing test case/task files forms a higher-level    suite. Such a <code>suite directory</code> has suites created from test   case/task files as its child suites.</li> <li>A suite directory can also contain other suite directories,   and this hierarchical structure can be as deeply nested as needed.</li> <li>Suite directories can have a special <code>initialization file</code>   configuring the created test suite.</li> </ul> <p>In addition, there are: - <code>Libraries</code> containing the lowest-level keywords. - <code>Resource files</code> with <code>variables</code> and higher-level <code>user keywords</code>. - <code>Variable files</code> to provide more flexible ways to create variables than resource files.</p> <p>Test case files, RPA suite files, suite initialization files and resource files are all created using Robot Framework input data syntax, whereas Libraries and variable files are created using \"real\" programming languages (most often, Python).</p>"},{"location":"using/data/#input-data-sections","title":"Input data sections","text":"<p>Robot Framework input data is defined in different sections, often also called tables, listed below:</p> Section Used for Settings <p>1) Importing <code>test libraries</code>, <code>resource files</code> and <code>variable files</code>.2) Defining metadata for <code>test suites</code>and <code>test cases</code>.</p> Variables Defining <code>variables</code> that can be used elsewhere in the input data. Test Cases <code>Creating test cases</code> from available keywords. Tasks <code>Creating tasks</code> using available keywords. Single file can only contain either tests or tasks. Keywords <code>Creating user keywords</code> from existing lower-level keywords Comments Additional comments or data. Ignored by Robot Framework. <p>Different sections are recognized by their header row and the recommended header format is <code>*** Settings ***</code>. The header is case-insensitive, surrounding spaces are optional and the number of asterisk characters can vary as long as there is at least one asterisk at the beginning. For example, also <code>*settings</code> would be recognized as a valid section header.</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Settings ***\nLibrary    BuiltIn\n\n** Variables ***\n${variable_name_here}     variable_value_here\n</code></pre> <p></p> <p>The header row can also contain other data besides that of the actual section header. The extra data must be separated from the section header using the data format dependent separator (typically two or more spaces). These extra headers are ignored at parsing time, but they can be used for documenting purposes. This is especially useful when creating test cases using the <code>data-driven style</code>.</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Settings ***    EU language support ok, South America &amp; Antarctica to be added Release 2.0\n</code></pre> <p></p> <p>\ud83d\udce2 NOTE: Any data which may be entered before the first section is ignored. \ud83d\udce2 NOTE: Section headers can be localized. See the Translations appendix for supported translations.</p>"},{"location":"using/data/#supported-file-formats","title":"Supported file formats","text":"<p>TODO:  stylise each of the file extension mentions  </p> <p>The most common approach to create Robot Framework input data is using the <code>space separated format</code> where pieces of the input data, such as keywords and their arguments, are separated from each other with two or more spaces. An alternative is using the <code>pipe separated format</code> where the separator is the pipe character surrounded with spaces (<code>|</code>).</p> <p>Suite files typically use the <code>.robot</code> file extension, but which files are parsed <code>can be configured</code>. <code>Resource files</code> can use the <code>.robot</code> file extension as well, but using the dedicated <code>.resource</code> file extension is recommended. Files containing non-ASCII characters must be saved using the UTF-8 encoding.</p> <p>HACK: removed \"and may be mandated in the future\" from above!</p> <p>Robot Framework supports also reStructuredText files so that normal input data is <code>embedded into code blocks</code>. Only files with the <code>.robot.rst</code> file extension are parsed by default. If you would rather use just <code>.rst</code> or <code>.rest</code>file extensions, they need to be configured separately.</p> <p>TODO:  how to configure this is missing above!</p> <p>Input data can also be created in the <code>JSON format</code> that is targeted more for tool developers than normal Robot Framework users. Only JSON files with the custom <code>.rbt</code> file extension are parsed by default.</p> <p>TODO:  what does \"tool developer\" mean here above?</p> <p>Earlier Robot Framework versions also supported input data in HTML and TSV formats. The TSV format still works if the input data is compatible with the <code>space separated format</code>, but the support for the HTML format has been removed altogether.</p> <p>If you encounter such input data files, you need to convert them to the plain text format to be able to use them with Robot Framework. The easiest way to do that is using the <code>Tidy</code> tool, but you must use the version included with Robot Framework 3.1 because newer Robot Framework versions do not understand the HTML format at all.</p> <p>TODO:  should we say why the HTML was removed here?</p>"},{"location":"using/data/#space-separated-format","title":"Space separated format","text":"<p>When Robot Framework parses input data, it first splits the input data to lines and then those lines to tokens such as keywords and arguments. When using the space separated format, the separator between tokens is two or more spaces, or alternatively one or more tab characters. In addition to the normal ASCII space, any Unicode character considered to be a space (i.e. non-breaking space) works as a separator also. The number of spaces used as a separator can vary, as long as there are at least two, making it possible to nicely align the input data when it makes the input data easier to understand.</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Settings ***\nDocumentation     Example using the space separated format.\nLibrary           OperatingSystem\n\n*** Variables ***\n${MESSAGE}        Hello, world!\n\n*** Test Cases ***\nMy Test\n    [Documentation]    Example test.\n    Log    ${MESSAGE}\n    My Keyword    ${CURDIR}\n\nAnother Test\n    Should Be Equal    ${MESSAGE}    Hello, world!\n\n*** Keywords ***\nMy Keyword\n    [Arguments]    ${path}\n    Directory Should Exist    ${path}\n</code></pre> <p></p> <p>Because tabs and consecutive spaces are considered separators, they must be escaped if they are needed in keyword arguments or elsewhere in the actual input data. It is possible to use special escape sequences  such as <code>\\t</code> for tab, <code>\\xA0</code> for a non-breaking space or the <code>built-in variables</code> <code>${SPACE}</code> and <code>${EMPTY}</code>. Please See the <code>Escaping</code> section for more details.</p> <p>\ud83d\udce2 _TIP: Although using two spaces as a separator is enough, it is recommended to use four spaces to make the separator easier to recognize.</p>"},{"location":"using/data/#pipe-separated-format","title":"Pipe separated format","text":"<p>The biggest problem of the space separated format is that visually separating keywords from arguments can be tricky. This is a problem especially if keywords take a lot of arguments and/or arguments contain spaces. In such cases the pipe delimited variant can work better because it makes the separator more visibly clearer and obvious.</p> <p>One file can contain both space separated and pipe separated lines. Pipe separated lines are recognized by the mandatory leading pipe character, but the pipe at the end of the line is optional. There must always be at least one space or tab on both sides of the pipe except at the beginning and at the end of the line. There is no need to align the pipes, but often this does make the input data easier to read.</p> \ud83e\udd16 EXAMPLE: <pre><code>| *** Settings ***   |\n| Documentation      | Example using the pipe separated format.\n| Library            | OperatingSystem\n\n| *** Variables ***  |\n| ${MESSAGE}         | Hello, world!\n\n| *** Test Cases *** |                 |               |\n| My Test            | [Documentation] | Example test. |\n|                    | Log             | ${MESSAGE}    |\n|                    | My Keyword      | ${CURDIR}     |\n| Another Test       | Should Be Equal | ${MESSAGE}    | Hello, world!\n\n| *** Keywords ***   |                        |         |\n| My Keyword         | [Arguments]            | ${path} |\n|                    | Directory Should Exist | ${path} |\n</code></pre> <p></p> <p>When using the pipe separated format, consecutive spaces or tabs inside arguments do not need to be escaped. Similarly empty columns do not need to be escaped except <code>if they are at the end of the libe</code>. Possible pipes surrounded by spaces in the actual input data must be escaped with a backslash, however.</p> \ud83e\udd16 EXAMPLE: <pre><code>| *** Test Cases *** |                 |                 |                      |\n| Escaping Pipe      | ${file count} = | Execute Command | ls -1 *.txt \\| wc -l |\n|                    | Should Be Equal | ${file count}   | 42                   |\n</code></pre> <p></p>"},{"location":"using/data/#restructuredtext-format","title":"reStructuredText format","text":"<p><code>reStructuredText</code> (reST) is an easy-to-read plain text markup syntax that is commonly used for documentation of Python projects including Python itself. reST documents are most often compiled to HTML, but other output formats are supported also. Using reST with Robot Framework allows you to mix richly formatted documents and input data in a concise text format that is easy to work with using simple text editors, diff tools, and source control systems.</p> <p>\ud83d\udce2 NOTE: Using reStructuredText files with Robot Framework requires the Python <code>docutils</code> module to be installed.</p> <p>When using Robot Framework with reStructuredText files, normal input data is embedded into so called code blocks. In standard reST, code blocks are marked using the <code>code</code> directive, but Robot Framework also supports  <code>code-block</code> or <code>sourcecode</code> directives used by the <code>Sphinx</code> tool.</p> <p>TODO:  normal input data used throughout here, better terminology or an initial explaination of this term would be good.</p> <p>TODO:  this is the 1st time Sphinx is introduced. Explain what it is further.</p> \ud83e\udd16 EXAMPLE: <pre><code> This text is outside code blocks and thus ignored.\n\n .. code:: robotframework\n\n    *** Settings ***\n    Documentation    Example using the reStructuredText format.\n    Library          OperatingSystem\n\n    *** Variables ***\n    ${MESSAGE}       Hello, world!\n\n    *** Test Cases ***\n    My Test\n        [Documentation]    Example test.\n        Log    ${MESSAGE}\n        My Keyword    ${CURDIR}\n\n    Another Test\n        Should Be Equal    ${MESSAGE}    Hello, world!\n\n Also this text is outside code blocks and ignored. Code blocks not\n containing input data are ignored as well.\n\n .. code:: robotframework\n\n    # Both space and pipe separated formats are supported.\n\n    | *** Keywords ***  |                        |         |\n    | My Keyword        | [Arguments]            | ${path} |\n    |                   | Directory Should Exist | ${path} |\n\n .. code:: python\n\n    # This code block is ignored.\n    def example():\n        print('Hello, world!')\n</code></pre> <p></p> <p>Robot Framework supports reStructuredText files using <code>.robot.rst</code>, <code>.rst</code> and <code>.rest</code> file extensions. To avoid parsing unrelated reStructuredText files, only files with the <code>.robot.rst</code> file extension are parsed by default when executing a directory. Parsing files with other file extensions <code>can be enabled</code> by using either :option:<code>--parseinclude</code> or :option:<code>--extension</code> option.</p> <p>TODO:  though not in the runner/execution section, add an example block here.</p> <p>When Robot Framework parses reStructuredText files, errors below the level <code>SEVERE</code> are ignored to avoid noise about possible non-standard directives and other such markup. This may hide also real errors, but they can be seen when processing files using reStructuredText tooling normally.</p> <p>TODO:  bit developer-y, need to link to the section on different output levels here. Re-word non-standard directives possibly too</p>"},{"location":"using/data/#json-format","title":"JSON format","text":"<p>Robot Framework also supports input data also in the <code>JSON</code> format. This format is designed typically more for tool developers than for regular Robot Framework users and it is not meant to be edited manually. Its most important use cases are: - Transferring input data between processes and machines. A suite can be converted to JSON on one machine and recreated back to a suite on another machine (serialization). - Saving a suite (possibly a nested suite), constructed from normal input data into a single JSON file which is faster to parse. - As an alternative input data format for external tools generating tests or tasks.</p>"},{"location":"using/data/#converting-suite-to-json","title":"Converting suite to JSON","text":"<p>A suite structure can be serialized into JSON by using the <code>TestSuite.to_json</code> method. When used without arguments, it returns JSON data as a string, but it also accepts a path or an open file where to write JSON data along with configuration options related to JSON formatting:</p> \ud83e\udd16 EXAMPLE: <pre><code>from robot.running import TestSuite\n\n\n# Create suite based on input data on the file system.\nsuite = TestSuite.from_file_system('/path/to/data')\n\n# Get JSON data as a string.\ndata = suite.to_json()\n\n# Save JSON data to a file with custom indentation.\nsuite.to_json('data.rbt', indent=2)\n</code></pre> <p></p> <p>If you would rather work with Python data and then convert that to JSON or some other format yourself, you can use <code>TestSuite.to_dict</code> instead. For more information, please see:  - https://robot-framework.readthedocs.io/en/master/au_c/robot.running.html#robot.running.model.TestSuite.to_json - https://robot-framework.readthedocs.io/en/master/au_c/robot.running.html#robot.running.model.TestSuite.to_dict</p>"},{"location":"using/data/#creating-suite-from-json","title":"Creating suite from JSON","text":"<p>A suite can be constructed from JSON data using the <code>TestSuite.from_json</code>  method. It works both with JSON strings and paths to JSON files:</p> \ud83e\udd16 EXAMPLE: <pre><code>from robot.running import TestSuite\n\n\n# Create suite from JSON data in a file.\nsuite = TestSuite.from_json('data.rbt')\n\n# Create suite from a JSON string.\nsuite = TestSuite.from_json('{\"name\": \"Suite\", \"tests\": [{\"name\": \"Test\"}]}')\n\n# Execute suite. Notice that log and report needs to be created separately.\nsuite.run(output='example.xml')\n</code></pre> <p></p> <p>If you have data as a Python dictionary, you can use <code>TestSuite.from_dict</code> instead. Regardless of how a suite is recreated, it exists only in memory and original data files on the file system are not recreated.</p> <p>As the above example demonstrates, the created suite can be executed using the <code>TestSuite.run</code> method. It may, however, be easier to execute a JSON file directly as explained in the following section.For more information, please see: </p> <ul> <li>https://robot-framework.readthedocs.io/en/master/au_c/robot.running.html#robot.running.model.TestSuite.from_json</li> <li>https://robot-framework.readthedocs.io/en/master/au_c/robot.running.html#robot.running.model.TestSuite.from_dict</li> <li>https://robot-framework.readthedocs.io/en/master/au_c/robot.running.html#robot.running.model.TestSuite.run</li> </ul> <p>TODO:  Following section likely needs to point to a different chapter later TODO:  Are these suite serialisations &amp; running topics related to test-data? are they in the best place here? TODO:  Examples of JSON produced maybe useful here</p>"},{"location":"using/data/#executing-json-files","title":"Executing JSON files","text":"<p>When executing tests or tasks using the <code>robot</code> command, JSON files with the custom <code>.rbt</code> file extension are parsed automatically. This includes running individual JSON files such as <code>robot tests.rbt</code> and running directories containing <code>.rbt</code> files. If you would rather use the standard <code>.json</code> file extension, you need to <code>configure which files are parsed</code>.</p>"},{"location":"using/data/#adjusting-suite-source","title":"Adjusting suite source","text":"<p>Suite source in the data obtained from <code>TestSuite.to_json</code> and <code>TestSuite.to_dict</code> is in absolute format. If a suite is recreated later on a different machine, the source thus, may not match the directory structure on that machine. To avoid this situation, it is possible to use the <code>TestSuite.adjust_source</code> method to make the suite source relative before obtaining the data and to add a correct root directory after the suite is recreated:</p> <p>TODO:  Explain absolute/relative here or link to it's definition online</p> \ud83e\udd16 EXAMPLE: <pre><code>from robot.running import TestSuite\n\n\n# Create a suite, adjust source and convert to JSON.\nsuite = TestSuite.from_file_system('/path/to/data')\nsuite.adjust_source(relative_to='/path/to')\nsuite.to_json('data.rbt')\n\n# Recreate suite elsewhere and adjust source accordingly.\nsuite = TestSuite.from_json('data.rbt')\nsuite.adjust_source(root='/new/path/to')\n</code></pre> <p></p> <p>For more information, please see: - https://robot-framework.readthedocs.io/en/master/au_c/robot.model.html#robot.model.testsuite.TestSuite.adjust_source</p>"},{"location":"using/data/#json-structure","title":"JSON structure","text":"<p>Imports, variables and keywords created in suite files are included in the generated JSON along with tests and tasks. The exact JSON structure is documented at <code>running.json</code> <code>schema file</code>.</p>"},{"location":"using/data/#rules-for-parsing-the-data","title":"Rules for parsing the data","text":""},{"location":"using/data/#ignored-data","title":"Ignored data","text":"<p>When Robot Framework parses input data files, it ignores:</p> <ul> <li>All data before the first <code>test data or task data section</code>.</li> <li>Data in the <code>Comments</code> section.</li> <li>All empty rows.</li> <li>All empty cells at the end of rows when using the <code>pipe separated format</code>.</li> <li>All single backslashes (<code>\\</code>) when not used for <code>escaping</code>.</li> <li>All characters following the hash character (<code>#</code>), when it is the first   character of a cell. This means that hash symbols can be used to enter   comments in the input data.</li> </ul> <p>When Robot Framework ignores some input data, this input data is not available in any resulting reports or logs and additionally, most tools used with Robot Framework also ignore them. To add information that is visible in Robot Framework outputs, place it to the documentation or other metadata of test cases, tasks or suites, or log it with the <code>BuiltIn</code> keywords <code>Log</code> or <code>Comment</code>.</p>"},{"location":"using/data/#escaping","title":"Escaping","text":"<p>The escape character in Robot Framework input data is the backslash (<code>\\</code>) and additionally <code>built-in variables</code> <code>${EMPTY}</code> and <code>${SPACE}</code> can often be used for escaping also. Different escaping mechanisms are discussed in the sections below.</p>"},{"location":"using/data/#escaping-special-characters","title":"Escaping special characters","text":"<p>The backslash character can be used to escape special characters so that their literal values are used.</p> Character Meaning Examples <code>\\$</code> Dollar sign, never starts a <code>scalar variable</code>. <code>\\${notvar}</code> <code>\\@</code> At sign, never starts a <code>list variable</code>_. <code>\\@{notvar}</code> <code>\\&amp;</code> Ampersand, never starts a <code>dictionary variable</code>_. <code>\\&amp;{notvar}</code> <code>\\%</code> Percent sign, never starts an <code>environment variable</code>_. <code>\\%{notvar}</code> <code>\\#</code> Hash sign, never starts a comment_. <code>\\# not comment</code> <code>\\=</code> Equal sign, never part of <code>named argument syntax</code>_. <code>not\\=named</code> <code>\\|</code> Pipe character, not a separator in the <code>pipe separated format</code>. <code>ls -1 *.txt \\| wc -l</code> <code>\\</code> Backslash character, never escapes anything. <code>c:\\\\temp, \\\\${var}</code>"},{"location":"using/data/#forming-escape-sequences","title":"Forming escape sequences","text":"<p>The backslash character also allows creating special escape sequences that are recognized as characters that would otherwise be difficult or impossible to create in the input data.</p> Sequence Meaning Examples <code>\\n</code> Newline character. <code>first line\\n2nd line</code> <code>\\r</code> Carriage return character <code>text\\rmore text</code> <code>\\t</code> Tab character. <code>text\\tmore text</code> <code>\\xhh</code> Character with hex value <code>hh</code>. <code>null byte: \\x00, \u00e4: \\xE4</code> <code>\\uhhhh</code> Character with hex value <code>hhhh</code>. <code>snowman: \\u2603</code> <code>\\Uhhhhhhhh</code> Character with hex value <code>hhhhhhhh</code>. <code>love hotel: \\U0001f3e9</code> <p>\ud83d\udce2 _NOTE: All strings created in the input data, including characters like <code>\\x02</code>, are Unicode and must be explicitly converted to byte strings if needed. This can be done, for example, using <code>Convert To Bytes</code> or <code>Encode String To Bytes</code> keywords in <code>BuiltIn</code> and <code>String</code> libraries respectively, or with <code>value.encode('UTF-8')</code> or similar in Python code.</p> <p>\ud83d\udce2 _NOTE: If invalid hexadecimal values are used with <code>\\x</code>, <code>\\u</code> or <code>\\U</code> escape sequences, the end result is the original value without the backslash character. For example, <code>\\xAX</code> (not hex) and <code>\\U00110000</code> (too large value) result with <code>xAX</code> and <code>U00110000</code> respectively. This behavior may change in future versions of Robot Framework, however.</p> <p>\ud83d\udce2 _NOTE: <code>Built-in variable</code> <code>${\\n}</code> can be used if an operating system-dependent line terminator is needed (<code>\\r\\n</code> on Windows and <code>\\n</code> elsewhere).</p>"},{"location":"using/data/#handling-empty-values","title":"Handling empty values","text":"<p>When using the <code>space separated format</code>, the number of spaces used as a separator can vary and thus empty values cannot be recognized unless they are escaped. Empty cells can be escaped either with the backslash character or with <code>built-in variable</code> <code>${EMPTY}</code>. The latter is typically recommended as it is easier to understand.</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nUsing backslash\n    Do Something    first arg    \\\n    Do Something    \\            second arg\n\nUsing ${EMPTY}\n    Do Something    first arg    ${EMPTY}\n    Do Something    ${EMPTY}     second arg\n</code></pre> <p></p> <p>When using the <code>pipe separated format</code>, empty values need to be escaped only when they are at the end of the row:</p> \ud83e\udd16 EXAMPLE: <pre><code>| *** Test Cases *** |              |           |            |\n| Using backslash    | Do Something | first arg | \\          |\n|                    | Do Something |           | second arg |\n|                    |              |           |            |\n| Using ${EMPTY}     | Do Something | first arg | ${EMPTY}   |\n|                    | Do Something |           | second arg |\n</code></pre> <p></p>"},{"location":"using/data/#handling-spaces","title":"Handling spaces","text":"<p>Spaces, especially consecutive spaces, as part of arguments for keywords or otherwise, are problematic for two reasons:</p> <ul> <li>Two or more consecutive spaces is considered a separator when using the   <code>space separated format</code>.</li> <li>Leading and trailing spaces are ignored when using the   <code>pipe separated format</code>.</li> </ul> <p>In these cases spaces need to be escaped. Similarly as when escaping empty values, it is possible to do this either by using the backslash character or by using the <code>built-in variable</code>_ <code>${SPACE}</code>.</p> Escaping with backslash Escaping with <code>${SPACE}</code> Notes <code>\\\\ leading space</code> <code>${SPACE}leading space</code> <code>trailing space \\\\</code> <code>trailing space${SPACE}</code> Backslash must be after the space. <code>\\\\ \\\\</code> <code>${SPACE}</code> Backslash needed on both sides. <code>consecutive \\\\ \\\\ spaces</code> <code>consecutive${SPACE * 3}spaces</code> Using <code>extended variable syntax</code>. <p>As the above examples show, using the <code>${SPACE}</code> variable often makes the input data easier to understand. It is especially useful in combination with the <code>extended variable syntax</code> when more than one space is needed.</p>"},{"location":"using/data/#dividing-data-to-several-rows","title":"Dividing data to several rows","text":"<p>If there is more data than readily fits a row, it is possible to split it  and start continuing rows with an ellipsis (<code>...</code>). Ellipses can be indented to match the indentation of the starting row and they must always be followed by the normal input data separator.</p> <p>In most places, split lines have exact same semantics as lines which are not split. Exceptions to this rule are <code>suite</code>, <code>test</code>, <code>task</code> and <code>keyword</code>  documentation as well as <code>suite metadata</code>. With these, split values are automatically <code>joined together with the newline character</code> to ease creating multiline values.</p> <p>The <code>...</code> syntax also allows splitting variables in the <code>Variable section</code>. When long scalar variables (i.e. <code>${STRING}</code>) are split to multiple rows, the final value is obtained by concatenating the rows together. The separator is a space by default, but that can be changed by starting the value with <code>SEPARATOR=&lt;sep&gt;</code>.</p> <p>TODO:  Add an example here</p> <p>Splitting lines is illustrated in the following two examples containing exactly the same input data with and and without splitting.</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Settings ***\nDocumentation      Here we have documentation for this suite.\\nDocumentation is often quite long.\\n\\nIt can also contain multiple paragraphs.\nDefault Tags       default tag 1    default tag 2    default tag 3    default tag 4    default tag 5\n\n*** Variables ***\n${STRING}          This is a long string. It has multiple sentences. It does not have newlines.\n${MULTILINE}       This is a long multiline string.\\nThis is the second line.\\nThis is the third and the last line.\n@{LIST}            this     list     is    quite    long     and    items in it can also be long\n&amp;{DICT}            first=This value is pretty long.    second=This value is even longer. It has two sentences.\n\n*** Test Cases ***\nExample\n    [Tags]    you    probably    do    not    have    this    many    tags    in    real    life\n    Do X    first argument    second argument    third argument    fourth argument    fifth argument    sixth argument\n    ${var} =    Get X    first argument passed to this keyword is pretty long    second argument passed to this keyword is long too\n</code></pre> <p></p> \ud83e\udd16 EXAMPLE: <pre><code>*** Settings ***\nDocumentation      Here we have documentation for this suite.\n...                Documentation is often quite long.\n...\n...                It can also contain multiple paragraphs.\nDefault Tags       default tag 1    default tag 2    default tag 3\n...                default tag 4    default tag 5\n\n*** Variables ***\n${STRING}          This is a long string.\n...                It has multiple sentences.\n...                It does not have newlines.\n${MULTILINE}       SEPARATOR=\\n\n...                This is a long multiline string.\n...                This is the second line.\n...                This is the third and the last line.\n@{LIST}            this     list     is      quite    long     and\n...                items in it can also be long\n&amp;{DICT}            first=This value is pretty long.\n...                second=This value is even longer. It has two sentences.\n\n*** Test Cases ***\nExample\n    [Tags]    you    probably    do    not    have    this    many\n    ...       tags    in    real    life\n    Do X    first argument    second argument    third argument\n    ...    fourth argument    fifth argument    sixth argument\n    ${var} =    Get X\n    ...    first argument passed to this keyword is pretty long\n    ...    second argument passed to this keyword is long too\n</code></pre> <p></p>"},{"location":"using/data/#localization","title":"Localization","text":"<p>Robot Framework localization efforts were started in Robot Framework 6.0 and allow translation of <code>section headers</code>, <code>settings</code>, <code>Given/When/Then prefixes</code> used in Behavior Driven Development (BDD) and <code>true and false strings</code> used in automatic boolean argument conversion. The plan is to extend localization support in the future - for example, to log and report outputs and possibly also to control structures.</p> <p>This section explains how to <code>activate languages</code>, what <code>built-in languages</code> are supported, how to create <code>custom language files</code> and how new translations can be contributed.</p>"},{"location":"using/data/#enabling-languages","title":"Enabling languages","text":""},{"location":"using/data/#using-command-line-option","title":"Using command line option","text":"<p>The main mechanism to activate languages is specifying them from the command line using the <code>--language</code> option. When enabling <code>built-in languages</code>, it is possible to use either the language name, such as <code>Finnish</code>, or the language code, such as <code>fi</code>. Both names and codes are case and space insensitive and any hyphen (<code>-</code>) is ignored. To enable multiple languages, the <code>--language</code> option needs to be used multiple times:</p> \ud83e\udd16 EXAMPLE: <pre><code> robot --language Finnish testit.robot\n robot --language pt --language ptbr testes.robot\n</code></pre> <p></p> <p>TODO:  Update examples throughout for clarity, remove abbreviations etc.</p> <p>The same <code>--language</code> option is used when activating <code>custom language files</code>. With them the value can be either a path to the file or, if the file is in the <code>module search path</code>, the module name:</p> \ud83e\udd16 EXAMPLE: <pre><code> robot --language Custom.py tests.robot\n robot --language MyLang tests.robot\n</code></pre> <p></p> <p>For backwards compatibility reasons, and to support partial translations, English is always activated automatically. Future versions may allow disabling it.</p>"},{"location":"using/data/#pre-file-configuration","title":"Pre-file configuration","text":"<p>It is also possible to enable languages directly in data files by having a line <code>Language:\u00a0&lt;value&gt;</code> (case-insensitive) before any of the section headers. The value after the colon is interpreted the same way as with the <code>--language</code> option:</p> \ud83e\udd16 EXAMPLE: <pre><code> Language: Finnish\n\n *** Asetukset ***\n Dokumentaatio        Example using Finnish.\n</code></pre> <p></p> <p>If there is a need to enable multiple languages, the <code>Language:</code> line can be repeated. These configuration lines cannot be in comments so code resembling  <code>#\u00a0Language: Finnish</code> or similar, has no effect.</p> <p>Due to technical limitations, the per-file language configuration also affects  parsing subsequent files as well as the whole execution. This behavior is likely to change in the future and should not be relied upon. If you use per-file configuration, use it with all files or enable languages globally with the <code>--language</code> option.</p> <p>TODO:   Example needed above</p>"},{"location":"using/data/#built-in-languages","title":"Built-in languages","text":"<p>The following languages are supported out-of-the-box. Click the language name to see further details of the actual translations:</p> <ul> <li><code>Bulgarian (bg)</code></li> <li><code>Bosnian (bs)</code></li> <li><code>Czech (cs)</code></li> <li><code>German (de)</code></li> <li><code>Spanish (es)</code></li> <li><code>Finnish (fi)</code></li> <li><code>French (fr)</code></li> <li><code>Hindi (hi)</code></li> <li><code>Italian (it)</code></li> <li><code>Dutch (nl)</code></li> <li><code>Polish (pl)</code></li> <li><code>Portuguese (pt)</code></li> <li><code>Brazilian Portuguese (pt-BR)</code></li> <li><code>Romanian (ro)</code></li> <li><code>Russian (ru)</code></li> <li><code>Swedish (sv)</code></li> <li><code>Thai (th)</code></li> <li><code>Turkish (tr)</code></li> <li><code>Ukrainian (uk)</code></li> <li><code>Vietnamese (vi)</code></li> <li><code>Chinese Simplified (zh-CN)</code></li> <li><code>Chinese Traditional (zh-TW)</code></li> </ul> <p>TODO: Add hyperlinks to each language above</p> <p>All these translations have been provided by the fantastic Robot Framework community. If a language you are interested in is not included, you can consider<code>contributing</code> it!</p>"},{"location":"using/data/#custom-language-files","title":"Custom language files","text":"<p>If a language you desire is not available as a built-in language, or you want to create a completely custom language for a specific need, you can easily create a custom language file. Language files are Python files which contain one or more language definitions that are all loaded when the language file is taken into use. Language definitions are created by extending the <code>robot.api.Language</code> base class and overriding class attributes as needed:</p> \ud83e\udd16 EXAMPLE: <pre><code> from robot.api import Language\n\n\n class Example(Language):\n     test_cases_header = 'Validations'\n     tags_setting = 'Labels'\n     given_prefixes = ['Assuming']\n     true_strings = ['OK', '\\N{THUMBS UP SIGN}']\n</code></pre> <p></p> <p>Assuming the above code would be in file <code>example.py</code>, a path to that file or just the module name <code>example</code> could be used when the language file is <code>activated</code>.</p> <p>The above example adds only some of the possible language translations, which is fine because English is automatically enabled anyway. Most values must be specified as strings, but BDD prefixes and true/false strings allow more than one value and must be given as lists. For more examples, see Robot Framework's internal <code>languages</code> module which contains the <code>Language</code> class as well as all built-in language definitions. - https://github.com/robotframework/robotframework/blob/master/src/robot/conf/languages.py</p>"},{"location":"using/data/#contributing-translations","title":"Contributing translations","text":"<p>If you want to add translation for a new language or enhance an existing language, please head to <code>Crowdin</code> which we use for collaboration. For more details, see the separate <code>Localization</code> project and for questions and free discussion join the <code>#localization</code> channel on our <code>Slack</code> pletform. - https://robotframework.crowdin.com - MarketSquare/localization</p>"},{"location":"using/execution/","title":"Executing test cases and tasks","text":"<ul> <li>Starting test execution</li> <li>Test execution</li> <li>Task execution</li> <li>Post-processing outputs</li> <li>Configuring execution</li> <li>Output files</li> <li>Basic usage</li> </ul>"},{"location":"using/execution/#basic-usage","title":"Basic usage","text":"<p>TODO:  Some form of info box here?</p> <p>Robot Framework test cases and RPA tasks are executed from the command line. The default resulting files generated are  - <code>XML format output</code> - <code>HTML report</code> - <code>log file</code> </p> <p>Post-execution, output files can be combined and otherwise post-processed with the Rebot tool.</p>"},{"location":"using/execution/#starting-test-execution","title":"Starting test execution","text":"\ud83e\udd16 EXAMPLE: <pre><code> robot [options] data\n python -m robot [options] data\n python path/to/robot/ [options] data\n</code></pre> <p> Execution is possible through multiple ways:</p> <ul> <li><code>robot command:</code> typically using the robot command  created as part of installation.</li> <li><code>robot module via Python interpreter:</code> execution of the installed robot module using the selected Python interpreter (this is especially convenient if Robot Framework has been installed under multiple Python versions). </li> <li><code>python:</code> using Python if you know where the installed robot directory exists, it can be executed using Python as well.</li> </ul> <p>Regardless of execution approach, the path(s) to the input data to be executed are provided as an argument after the command. Additionally, different command line options can be used to alter the test execution or generated outputs in many ways.</p>"},{"location":"using/execution/#specifying-input-data-to-be-executed","title":"Specifying input data to be executed","text":"<p>Robot Framework test cases and/or RPA tasks are created in files and directories and they are executed by providing the path to the file or directory in question, to the selected runner script. The path can be absolute or, more commonly, relative to the directory where tasks are executed from. The given file or directory creates the top-level suite, which, by default, gets its name from the file or directory name. Different execution possibilities are illustrated in the examples below. Note that in these examples, as well as in other examples in this section, only the robot script is used, but other execution approaches could be used similarly.</p> \ud83e\udd16 EXAMPLE: <pre><code> robot tests.robot\n robot path/to/my_tests/\n robot c:\\robot\\tests.robot\n</code></pre> <p></p> <p>\ud83d\udce2 NOTE: When executing a directory, all files and directories starting with a dot (.) or an underscore () are ignored and by default, only files with the .robot extension are executed. See the Selecting files to parse section for more details.</p> <p>It is also possible to give paths to several test case files or directories at once, separated with spaces. In this case, Robot Framework creates the top-level test suite automatically, and the specified files and directories become its child suites. The name of the created suite originates from child suite names by concatenating them togethser with an ampersand (&amp;) and spaces. For example, the name of the top-level suite in the first example below is My Tests &amp; Your Tests. These automatically created names are often quite long and complicated. In most cases, it is thus better to use the --name option for overriding it, as in the second example below:</p> \ud83e\udd16 EXAMPLE: <pre><code> robot my_tests.robot your_tests.robot\n robot --name Example path/to/tests/pattern_*.robot\n</code></pre> <p> Starting from Robot Framework 6.1, it is also possible to define a test suite initialisation file for the automatically created top-level suite. The path to the init file is given similarly to the test case files:</p> \ud83e\udd16 EXAMPLE: <pre><code> robot __init__.robot my_tests.robot other_tests.robot\n</code></pre> <p></p>"},{"location":"using/execution/#using-command-line-options","title":"Using command line options","text":"<p>Robot Framework provides a number of command line options which can be used to control how test cases and RPA tasks are executed and what outputs are generated. This section explains the option syntax, and which options actually exist. How they can be used is discussed elsewhere in this chapter.</p>"},{"location":"using/execution/#using-options","title":"Using options","text":"<p>When options are used, they must always be given between the runner script and the data sources. For example:</p> \ud83e\udd16 EXAMPLE: <pre><code>robot -L debug my_tests.robot\nrobot --include smoke --variable HOST:10.0.0.42 path/to/tests/\n</code></pre> <p></p>"},{"location":"using/execution/#short-and-long-options","title":"Short and long options","text":"<p>Options always have a long name, such as --name and the most frequently needed options also have a short name, such as -N. In addition to that, long options can be shortened as long as they are unique. For example, --logle DEBUG works, while --lo log.html does not, because the former matches only --loglevel, but the latter matches several options. Short and shortened options are practical when executing test cases manually, but long options are recommended in start-up scripts, because they are easier to understand.</p> <p>The long option names are case-insensitive and hyphen-insensitive, which facilitates writing option names in an easy-to-read format. For example, --SuiteStatLevel and --suite-stat-level are equivalent to, but easier to read than, --suitestatlevel.</p> <p>\ud83d\udce2 _NOTE: Long options being hyphen-insensitive is new in Robot Framework 6.1.</p>"},{"location":"using/execution/#setting-option-values","title":"Setting option values","text":"<p>Most of the options require a value, which is given after the option name. Both short and long options accept the value separated from the option name with a space, as in --include tag or -i tag. With long options, the separator can also be the equals sign, for example --include=tag, and with short options the separator can be omitted, as in -itag.</p> <p>Some options can be specified several times. For example, --variable VAR1:value --variable VAR2:another sets two variables. If the options that take only one value are used several times, the value provided last is effective.</p>"},{"location":"using/execution/#disabling-options-accepting-no-values","title":"Disabling options accepting no values","text":"<p>Options accepting no values can be disabled by using the same option again with no prefix added or dropped. The last option has precedence regardless of how many times options are used. For example, --dryrun --dryrun --nodryrun --nostatusrc --statusrc would not activate the dry-run mode and would return normal status rc.</p>"},{"location":"using/execution/#simple-patterns","title":"Simple patterns","text":"<p>Many command line options take arguments as simple patterns. These glob-like patterns are matched according to the following rules:</p> <ul> <li><code>*</code> matches any string, even an empty string.</li> <li><code>?</code> matches any single character.</li> <li><code>[abc]</code> matches one character in the bracket.</li> <li><code>[!abc]</code> matches one character not in the bracket.</li> <li><code>[a-z]</code> matches one character from the range in the bracket.</li> <li><code>[!a-z]</code> matches one character not from the range in the bracket.</li> </ul> <p>Unlike with glob patterns normally, path separator characters / and \\ and the newline character \\n are matches by the above wildcards. Unless noted otherwise, pattern matching is case, space, and underscore insensitive.</p> \ud83e\udd16 EXAMPLES: <pre><code>--test Example*        # Matches tests with name starting 'Example'.\n--test Example[1-2]    # Matches tests 'Example1' and 'Example2'.\n--include f??          # Matches tests with a tag that starts with 'f' is three characters long.\n</code></pre> <p></p> <p>All matches in the above examples are case, space and underscore insensitive. For example, the second example would also match test named example 1.</p> <p>If the matched text happens to contain some of the wildcard characters and they need to be matched literally, it is possible to do that by using the [...] syntax. The pattern [*] matches the literal * character, [?] matches ?, and [[] matches [. Lone [ and ] do not need to be escaped.</p> <p>\ud83d\udce2 _NOTE: Support for brackets such as [abc] and [!a-z] is new in Robot Framework 3.1.</p>"},{"location":"using/execution/#tag-patterns","title":"Tag patterns","text":"<p>Most tag related options accept arguments as tag patterns. They support same wildcards as simple patterns (e.g. examp??, ex*le), but they also support AND, OR and NOT operators explained below. These operators can be used for combining two or more individual tags or patterns together.</p>"},{"location":"using/execution/#and-or","title":"AND or &amp;","text":"<p>The whole pattern matches if all individual patterns match. AND and &amp; are equivalent:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include fooANDbar     # Matches tests containing tags 'foo' and 'bar'.\n--exclude xx&amp;yy&amp;zz      # Matches tests containing tags 'xx', 'yy', and 'zz'.\n</code></pre> <p></p>"},{"location":"using/execution/#or","title":"OR","text":"<p>The whole pattern matches if any individual pattern matches:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include fooORbar      # Matches tests containing either tag 'foo' or tag 'bar'.\n--exclude xxORyyORzz    # Matches tests containing any of tags 'xx', 'yy', or 'zz'.\n</code></pre> <p></p>"},{"location":"using/execution/#not","title":"NOT","text":"<p>The whole pattern matches if the pattern on the left side matches but the one on the right side does not. If used multiple times, none of the patterns after the first NOT must not match:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include fooNOTbar     # Matches tests containing tag 'foo' but not tag 'bar'.\n--exclude xxNOTyyNOTzz  # Matches tests containing tag 'xx' but not tag 'yy' or tag 'zz'.\n</code></pre> <p></p> <p>The pattern can also start with NOT in which case the pattern matches if the pattern after NOT does not match:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include NOTfoo        # Matches tests not containing tag 'foo'\n--include NOTfooANDbar  # Matches tests not containing tags 'foo' and 'bar'\n</code></pre> <p></p> <p>The above operators can also be used together. The operator precedence, from highest to lowest, is AND, OR and NOT:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include xANDyORz      # Matches tests containing either tags 'x' and 'y', or tag 'z'.\n--include xORyNOTz      # Matches tests containing either tag 'x' or 'y', but not tag 'z'.\n--include xNOTyANDz     # Matches tests containing tag 'x', but not tags 'y' and 'z'.\n</code></pre> <p></p> <p>Although tag matching itself is case-insensitive, all operators are case-sensitive and must be written with upper case letters. If tags themselves happen to contain upper case AND, OR or NOT, they need to specified using lower case letters to avoid accidental operator usage:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include port          # Matches tests containing tag 'port', case-insensitively\n--include PORT          # Matches tests containing tag 'P' or 'T', case-insensitively\n--exclude handoverORportNOTnotification\n</code></pre> <p></p>"},{"location":"using/execution/#robot_options-and-rebot_options-environment-variables","title":"ROBOT_OPTIONS and REBOT_OPTIONS environment variables","text":"<p>Environment variables ROBOT_OPTIONS and REBOT_OPTIONS can be used to specify default options for execution and result post-processing, respectively. The options and their values must be defined as a space separated list and they are placed in front of any explicit options on the command line. The main use case for these environment variables is setting global default values for certain options to avoid the need to repeat them every time tests/tasks are run or Rebot is used.</p> \ud83e\udd16 EXAMPLE: <pre><code>export ROBOT_OPTIONS=\"--outputdir results --tagdoc 'mytag:Example doc with spaces'\"\nrobot tests.robot\nexport REBOT_OPTIONS=\"--reportbackground blue:red:yellow\"\nrebot --name example output.xml\n</code></pre> <p></p>"},{"location":"using/execution/#test-results","title":"Test results","text":""},{"location":"using/execution/#command-line-output","title":"Command line output","text":"<p>The most visible output from test execution is the output displayed in the command line. All executed suites and test cases/RPA tasks, as well as their statuses, are shown there in real time. The example below shows the output from executing a simple test suite with only two test cases:</p> <p>TODO:  Alter below with escape sequence. CSS? image?</p> \ud83e\udd16 EXAMPLE:     ``` \\==============================================================================  \\Example test suite  \\==============================================================================  \\First test :: Possible test documentation                             | PASS |  \\------------------------------------------------------------------------------  \\Second test                                                           | FAIL |  \\Error message is displayed here  \\==============================================================================  \\Example test suite                                                    | FAIL |  \\2 tests, 1 passed, 1 failed  \\==============================================================================  \\Output:  /path/to/output.xml  \\Report:  /path/to/report.html  \\Log:     /path/to/log.html    ```  <p></p> <p>There is also a notification on the console whenever a top-level keyword in a test case/RPA task ends. A green dot is used if a keyword passes and a red F if it fails. These markers are written to the end of line and they are overwritten by the execution status when the execution itself ends. Writing the markers is disabled if console output is redirected to a file.</p>"},{"location":"using/execution/#generated-output-files","title":"Generated output files","text":"<p>The command line output is very limited and separate output files are usually needed for investigating the execution results. As the example above shows, three output files are generated by default. The first one is in XML format and contains all the information about test execution. The second is a higher-level report and the third is a more detailed log file. These files and other possible output files are discussed in more detail in the section Different output files.</p>"},{"location":"using/execution/#return-codes","title":"Return codes","text":"<p>Runner scripts communicate the overall execution status to the system running them using return codes. When the execution starts successfully and no tests/RPA tasks fail, the return code is zero. All possible return codes are explained in the table below.</p> <p>Possible return codes |   Return code |                 Explanation                       | |:---           |:---                                               | |   0           |   All tests passed.                               |  |   1-249       |   Returned number of tests failed.                |  |   250         |   250 or more failures.                           |  |   251         |   Help or version information printed.            |  |   252         |   Invalid input data or command line options.     |  |   253         |   Test execution stopped by user.                 |  |   255         |   Unexpected internal error.                      |   </p> <p>Return codes should always be easily available after the execution, which makes it easy to automatically determine the overall execution status. For example, in a bash shell the return code is in special variable $?, and in Windows it is in %ERRORLEVEL% variable. If you use another external tool for running tests, consult its documentation for how to retrieve the return code.</p> <p>The return code can be set to 0 even if there are failures using the --NoStatusRC command line option. This might be useful, for example, in continuous integration servers where post-processing of results is needed before the overall status of execution can be determined.</p> <p>\ud83d\udce2 _NOTE: Same return codes are also used with Rebot.</p>"},{"location":"using/execution/#errors-and-warnings-during-execution","title":"Errors and warnings during execution","text":"<p>During the test execution there can be unexpected problems such as failing to import a library or a resource file, or a keyword being deprecated, for example. Depending on the severity, such problems are categorized as errors or warnings and they are written into the console (using the standard error stream), shown on a separate Test/Task Execution Errors section in log files and also written into Robot Framework's own system log. Normally these errors and warnings are generated by Robot Framework itself, but libraries can also log errors and warnings. The example below illustrates how errors and warnings appear in the log file.</p> \ud83e\udd16 EXAMPLE: <pre><code>20090322 19:58:42.528    ERROR   Error in file '/home/robot/tests.robot' in table 'Setting' in element on row 2: Resource file 'resource.robot' does not exist\n20090322 19:58:43.931    WARN    Keyword 'SomeLibrary.Example Keyword' is deprecated. Use keyword `Other Keyword` instead.\n</code></pre> <p></p>"},{"location":"using/execution/#argument-files","title":"Argument files","text":"<p>Argument files allow placing all or some command line options and arguments into an external file where they will be read. This avoids the problems with characters which are problematic on the command line. If many options or arguments are needed, argument files also prevent the command which is used on the command line, growing too long.</p> <p>Argument files are taken into use with --argumentfile (-A) option along with possible other command line options.</p> <p>\ud83d\udce2 _NOTE: Unlike other long command line options, --argumentfile cannot be given in shortened format like --argumentf.</p>"},{"location":"using/execution/#argument-file-syntax","title":"Argument file syntax","text":"<p>Argument files can contain both command line options and paths to the input data, one option or data source per line. Both short and long options are supported, but the latter are recommended because they are easier to understand. Argument files can contain any characters without escaping, but spaces in the beginning and end of lines are ignored. Additionally, empty lines and lines starting with a hash mark (#) are ignored:</p> \ud83e\udd16 EXAMPLE: <pre><code>--doc This is an example (where \"special characters\" are ok!)\n--metadata X:Value with spaces\n --variable VAR:Hello, world!\n# This is a comment\npath/to/my/tests\n</code></pre> <p></p> <p>In the above example the separator between options and their values is a single space. It is possible to use either an equal sign (=) or any number of spaces. As an example, the following three lines are identical:</p> \ud83e\udd16 EXAMPLE: <pre><code>--name An Example\n--name=An Example\n--name       An Example\n</code></pre> <p></p> <p>If argument files contain non-ASCII characters, they must be saved using UTF-8 encoding.</p>"},{"location":"using/execution/#using-argument-files","title":"Using argument files","text":"<p>Argument files can be used either alone so that they contain all the options and paths to the input data, or along with other options and paths. When an argument file is used with other arguments, its contents are placed into the original list of arguments to the same place where the argument file option was. This means that options in argument files can override options before it, and its options can be overridden by options after it. It is possible to use --argumentfile option multiple times or even recursively:</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --argumentfile all_arguments.robot\nrobot --name Example --argumentfile other_options_and_paths.robot\nrobot --argumentfile default_options.txt --name Example my_tests.robot\nrobot -A first.txt -A second.txt -A third.txt tests.robot\n</code></pre> <p></p>"},{"location":"using/execution/#reading-argument-files-from-standard-input","title":"Reading argument files from standard input","text":"<p>A special argument file name STDIN can be used to read arguments from the standard input stream instead of a file. This can be useful when generating arguments with a script:</p> \ud83e\udd16 EXAMPLE: <pre><code>generate_arguments.sh | robot --argumentfile STDIN\ngenerate_arguments.sh | robot --name Example --argumentfile STDIN tests.robot\n</code></pre> <p></p>"},{"location":"using/execution/#getting-help-and-version-information","title":"Getting help and version information","text":"<p>Both when executing test cases and when post-processing outputs, it is possible to get command line help with the option --help (-h). These help texts have a short general overview and briefly explain the available command line options.</p> <p>All runner scripts also support getting the version information with the option --version. This information also contains both the Python version and the platform type:</p> \ud83e\udd16 EXAMPLE: <pre><code>$ robot --version\nRobot Framework 7.0 (Python 3.12.1 on darwin)\n\nC:\\&gt;rebot --version\nRebot 6.1.1 (Python 3.11.0 on win32)\n</code></pre> <p></p>"},{"location":"using/execution/#creating-start-up-scripts","title":"Creating start-up scripts","text":"<p>Test cases/RPA tasks are often executed automatically by a continuous integration system or some other automated mechanism. In such cases, there is a need to have a script for starting the execution and possibly also for post-processing outputs somehow. Similar scripts are also useful when executing manually, especially if a large number of command line options are needed or setting up the test environment is complicated.</p> <p>In UNIX-like environments, shell scripts provide a simple but powerful mechanism for creating custom start-up scripts. Windows batch files can also be used, but they are more limited and often also more complicated. A platform-independent alternative is using Python or some other high-level programming language. Regardless of the language, it is recommended that long option names are used, because they are easier to understand than the short names.</p>"},{"location":"using/execution/#shell-script-example","title":"Shell script example","text":"<p>In this example, the same web tests/tasks in the login directory are executed with different browsers and the results are combined afterwards using Rebot. The script also accepts command line options itself and simply forwards them to the robot command using the handy $* variable:</p> \ud83e\udd16 EXAMPLE: <pre><code>#!/bin/bash\nrobot --name Firefox --variable BROWSER:Firefox --output out/fx.xml --log none --report none $* login\nrobot --name IE --variable BROWSER:IE --output out/ie.xml --log none --report none  $* login\nrebot --name Login --outputdir out --output login.xml out/fx.xml out/ie.xml\n</code></pre> <p></p>"},{"location":"using/execution/#batch-file-example","title":"Batch file example","text":"<p>Implementing the above shell script example using batch files is not very complicated either. Notice that arguments to batch files can be forwarded to executed commands using %*:</p> \ud83e\udd16 EXAMPLE: <pre><code>@echo off\nrobot --name Firefox --variable BROWSER:Firefox --output out\\fx.xml --log none --report none %* login\nrobot --name IE --variable BROWSER:IE --log none --output out\\ie.xml --report none %* login\nrebot --name Login --outputdir out --output login.xml out\\fx.xml out\\ie.xml\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE:Prior to Robot Framework 3.1 robot and rebot commands were implemented as batch files on Windows and using them in another batch file required prefixing the whole command with call.</p>"},{"location":"using/execution/#python-example","title":"Python example","text":"<p>When start-up scripts get more complicated, implementing them using shell scripts or batch files is not so convenient. This is especially true if both variants are needed and same logic needs to be implemented twice. In such situations it is often better to switch to Python. It is possible to execute Robot Framework from Python using the subprocess module, but often using Robot Framework's own programmatic API is more convenient. The easiest APIs to use are robot.run_cli and robot.rebot_cli that accept same command line arguments than the robot and rebot commands.</p> <p>The following example implements the same logic as the earlier shell script and batch file examples. In Python, arguments to the script itself are available in sys.argv:</p> \ud83e\udd16 EXAMPLE: <pre><code>#!/usr/bin/env python\nimport sys\nfrom robot import run_cli, rebot_cli\n\ncommon = ['--log', 'none', '--report', 'none'] + sys.argv[1:] + ['login']\nrun_cli(['--name', 'Firefox', '--variable', 'BROWSER:Firefox', '--output', 'out/fx.xml'] + common, exit=False)\nrun_cli(['--name', 'IE', '--variable', 'BROWSER:IE', '--output', 'out/ie.xml'] + common, exit=False)\nrebot_cli(['--name', 'Login', '--outputdir', 'out', 'out/fx.xml', 'out/ie.xml'])\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: exit=False is needed because by default, run_cli exits to system with the correct return code. rebot_cli does that also, but in the above example that is fine.</p>"},{"location":"using/execution/#making-robot-files-executable","title":"Making *.robot files executable","text":"<p>On UNIX-like operating systems it is possible to make *.robot files executable by giving them execution permission and adding a shebang like in this example:</p> \ud83e\udd16 EXAMPLE: <pre><code>#!/usr/bin/env robot\n\n*** Test Cases ***\nExample\n       Log to console    Executing!\n</code></pre> <p></p> <p>If the above content would be in a file example.robot and that file would be executable, it could be executed from the command line as  below. Starting from Robot Framework 3.2, individually executed files can have any extension, or no extension at all, so the same would work also if the file would be named just example.</p> \ud83e\udd16 EXAMPLE: <pre><code>./example.robot\n</code></pre> <p></p> <p>This trick does not work when executing a directory but can be useful when executing a single file. It is probably more often useful when automating tasks than when automating tests.</p>"},{"location":"using/execution/#debugging-problems","title":"Debugging problems","text":"<p>A test case can fail because the system under test/RPA system does not work correctly, in which case the test/task has found a bug, or because the test/task itself is buggy. The error message explaining the failure is shown on the command line output and in the report file, and sometimes the error message alone is enough to pinpoint the problem. More often that not, however, log files are needed because they also contain other log messages and they show which keyword actually failed.</p> <p>When a failure is caused by the application, the error message and log messages ought to be enough to understand what caused it. If that is not the case, the executed library does not provide enough information and needs to be enhanced. In this situation running the same test/task manually, if possible, may also reveal more information about the issue.</p> <p>Failures caused by test cases/RPA tasks themselves or by keywords they use can sometimes be difficult to debug. If the error message, for example, tells that a keyword is used with wrong number of arguments fixing the problem is obviously easy, but if a keyword is missing or fails in unexpected way finding the root cause can be harder. The first place to look for more information is the execution errors section in the log file. For example, an error about a failed library import may well explain why a test/task has failed due to a missing keyword.</p> <p>If the log file does not provide enough information by default, it is possible to execute tests with a lower log level. For example tracebacks showing where in the code the failure occurred are logged using the DEBUG level, and this information is invaluable when the problem is in an individual library keyword.</p> <p>Logged tracebacks do not contain information about methods inside Robot Framework itself. If you suspect an error is caused by a bug in the framework, you can enable showing internal traces by setting the environment variable ROBOT_INTERNAL_TRACES to any non-empty value.</p> <p>If the log file still does not detail enough information, it is a good idea to enable the syslog and see what information it provides. It is also possible to add some keywords to the test cases/RPA tasks to further see what is going on. Especially BuiltIn keywords Log and Log Variables are useful. If nothing else works, it is always possible to search help from mailing lists or elsewhere.</p> <p>TODO:  Video demos of each example could be useful!</p>"},{"location":"using/execution/#using-the-python-debugger-pdb","title":"Using the Python debugger (pdb)","text":"<p>It is also possible to use the pdb module from the Python standard library to set a break point and interactively debug a running test. The typical way of invoking pdb, by inserting the following code at the location you want to break into debugger, will not work correctly with Robot Framework, as the standard output stream is redirected during keyword execution.</p> \ud83e\udd16 EXAMPLE: <pre><code>import pdb; pdb.set_trace()\n</code></pre> <p></p> <p>Instead, you can use the following code from within a python library</p> \ud83e\udd16 EXAMPLE: <pre><code>import sys, pdb; pdb.Pdb(stdout=sys.__stdout__).set_trace()\n</code></pre> <p></p> <p>or alternatively this code instead can be used directly in a test case/RPA task.</p> \ud83e\udd16 EXAMPLE: <pre><code>Evaluate    pdb.Pdb(stdout=sys.__stdout__).set_trace()    modules=sys, pdb\n</code></pre> <p></p>"},{"location":"using/execution/#test-execution","title":"Test execution","text":"<p>This section describes how the suite structure created from the parsed input data is executed, how Test status is determined, how to continue executing a test case if there are failures and how to stop the whole execution gracefully.</p>"},{"location":"using/execution/#execution-flow","title":"Execution flow","text":""},{"location":"using/execution/#executed-suites-and-tests","title":"Executed suites and tests","text":"<p>test cases are always executed within a suite. A suite created from a suite file has tests directly, whereas suites created from directories have child suites which either have tests or their own child suites. By default all the tests in an executed suite are run, but it is possible to select specific ones using options --test, --suite, --include and --exclude. Suites containing no tests are ignored.</p> <p>The execution starts from the top-level suite. If the suite has tests they are executed one-by-one, and if it has suites they are executed recursively in depth-first order. When an individual test case is executed, the keywords it contains are run in a sequence. Normally the execution of the current Test ends if any of the keywords fails, but it is also possible to continue after failures. The exact execution order and how possible setups and teardowns affect the execution are discussed in the following sections.</p>"},{"location":"using/execution/#setups-and-teardowns","title":"Setups and teardowns","text":"<p>Setups and teardowns can be used on suite, test case and user keyword levels.</p>"},{"location":"using/execution/#suite-setup","title":"Suite setup","text":"<p>If a suite has a setup, it is executed before its tests and child suites. If the suite setup passes, execution continues normally. If it fails, all the test cases the suite and its child suites contain are marked failed. The tests and possible suite setups and teardowns in the child suites are not executed.</p> <p>Suite setups are often used for setting up the execution environment. Because tests are not run if the suite setup fails, it is easy to use suite setups for verifying that the environment is in state in which the tests can be executed.</p>"},{"location":"using/execution/#suite-teardown","title":"Suite teardown","text":"<p>If a suite has a teardown, it is executed after all its test cases and child suites. Suite teardowns are executed regardless of the execution status and even if the matching suite setup fails. If the suite teardown fails, all tests in the suite are marked failed afterwards in reports and logs.</p> <p>Suite teardowns are mostly used for cleaning up the test environment after the execution. To ensure that all these tasks are done, all the keywords used in the teardown are executed even if some of them fail.</p>"},{"location":"using/execution/#test-setup","title":"Test setup","text":"<p>Possible Test setup is executed before the keywords of the test case. If the setup fails, the keywords are not executed. The main use for Test setups is setting up the environment for that particular test case.</p>"},{"location":"using/execution/#test-teardown","title":"Test teardown","text":"<p>Possible Test teardown is executed after the test case has been executed. It is executed regardless of the execution status and also if Test setup has failed.</p> <p>Similarly as suite teardown, Test teardowns are used mainly for cleanup activities. Also they are executed fully even if some of their keywords fail.</p>"},{"location":"using/execution/#user-keyword-setup","title":"User keyword setup","text":"<p>User keyword setup is executed before the keyword body. If the setup fails, the body is not executed. There is not much difference between the keyword setup and the first keyword in the body.</p> <p>\ud83d\udce2 _NOTE: User keyword setups are new in Robot Framework 7.0.</p>"},{"location":"using/execution/#user-keyword-teardown","title":"User keyword teardown","text":"<p>User keyword teardown is run after the keyword is executed otherwise, regardless the status. User keyword teardowns are executed fully even if some of their keywords would fail.</p>"},{"location":"using/execution/#execution-order","title":"Execution order","text":"<p>test cases in a suite are executed in the same order as they are defined in the test case file. Suites inside a higher level suite are executed in a case-insensitive alphabetical order based on the file or directory name. If multiple files and/or directories are provided from the command line, they are executed in the order they are provided.</p> <p>If there is a need to use a certain test execution order inside a directory, it is possible to add prefixes such as 01 and 02 into file and directory names. Such prefixes are not included in the generated suite name if they are separated from the base name of the suite with two underscores:</p> \ud83e\udd16 EXAMPLE: <pre><code>01__my_suite.robot -&gt; My Suite\n02__another_suite.robot -&gt; Another Suite\n</code></pre> <p></p> <p>If the alphabetical ordering of suites inside suites is problematic, a good workaround is providing  them separately in the required order. This easily leads to overly long start-up commands, but argument files allow listing files nicely one file per line.</p> <p>It is also possible to randomize the execution order using the --randomize option.</p>"},{"location":"using/execution/#test-and-suite-statuses","title":"Test and suite statuses","text":"<p>This section explains how tests can get PASS, FAIL or SKIP status and how the suite status is determined based on Test statuses.</p> <p>\ud83d\udce2 _NOTE: The SKIP status is new in Robot Framework 4.0.</p>"},{"location":"using/execution/#pass","title":"PASS","text":"<p>A Test gets the PASS status if it is executed and none of the keywords it contains fails.</p>"},{"location":"using/execution/#prematurely-passing-tests","title":"Prematurely passing tests","text":"<p>Typically, all keywords are executed, but it is also possible to use BuiltIn keywords Pass Execution and Pass Execution If to stop execution with the PASS status and not to continue run the remaining keywords.</p> <p>How Pass Execution and Pass Execution If behave in different situations is explained below:</p> <ul> <li>When used in any setup or teardown (suite, Test or keyword), these keywords pass that setup or teardown. Possible teardowns of the started keywords are executed. Test execution or statuses are not affected otherwise.</li> <li>When used in a test case outside setup or teardown, the keywords pass that particular test case. </li> <li>Possible test and keyword teardowns are executed.</li> <li>Possible continuable failures that occur before these keyword are used, as well as failures in teardowns executed afterwards, will fail the execution.</li> <li>It is mandatory to give an explanation message why execution was interrupted, and it is also possible to modify test case tags. For more details, and usage examples, see the documentation of these keywords.</li> </ul> <p>Passing execution in the middle of a Test, setup or teardown should be used with care. In the worst case it leads to tests which skip all the parts that could actually uncover problems in the tested application. In cases where execution cannot continue do to external factors, it is often safer to skip the Test.</p>"},{"location":"using/execution/#fail","title":"FAIL","text":"<p>The most common reason for a Test to be assigned the FAIL status is that one of the keywords it contains fails. The keyword itself can fail by raising an exception or the keyword can be called incorrectly. Other reasons for failures include syntax errors and the Test being empty.</p> <p>If a suite setup fails, tests in that suite are marked failed without running them. If a suite teardown fails, tests are marked failed retroactively.</p>"},{"location":"using/execution/#skip","title":"SKIP","text":"<p>Starting from Robot Framework 4.0, tests can get also SKIP status in addition to PASS and FAIL. There are many different ways to get this status.</p>"},{"location":"using/execution/#skipping-before-execution","title":"Skipping before execution","text":"<p>The command line option --skip can be used to skip specified tests without running them at all. It works based on tags and supports tag patterns like examp?? and tagANDanother. If it is used multiple times, all tests matching any of specified tags or tag patterns are skipped:</p> \ud83e\udd16 EXAMPLE: <pre><code>--skip require-network\n--skip windowsANDversion9?\n--skip python2.* --skip python3.[0-6]\n</code></pre> <p></p> <p>Starting from Robot Framework 5.0, a test case can also be skipped by tagging the test with the reserved tag robot:skip:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n    [Tags]    robot:skip\n    Log       This is not executed\n</code></pre> <p></p> <p>The difference between --skip and --exclude is that with the latter, tests are omitted from the execution altogether and they will not be shown in logs and reports. With the former they are included, but not actually executed, and they will be visible in logs and reports.</p>"},{"location":"using/execution/#skipping-dynamically-during-execution","title":"Skipping dynamically during execution","text":"<p>Tests can get the skip status during execution in various ways:</p> <ul> <li>Using the BuiltIn keyword Skip anywhere in the test case, including setup or teardown. Using Skip keyword has two effects: the test gets the SKIP status and rest of the Test is not executed. However, if the Test has a teardown, it will be run.</li> <li>Using the BuiltIn keyword Skip If which takes a condition and skips the Test if the condition is true.</li> <li>Library keywords may also trigger skip behavior by using a special exceptions. This is explained the Skipping tests section in the Creating libraries chapter.</li> <li>If suite setup is skipped using any of the above means, all tests in the suite are skipped without executing them.</li> <li>If suite teardown is skipped, all tests will be marked skipped retroactively.</li> </ul>"},{"location":"using/execution/#automatically-skipping-failed-tests","title":"Automatically skipping failed tests","text":"<p>The command line option --skiponfailure can be used to automatically mark failed tests skipped. It works based on tags and supports tag patterns like the --skip option discussed above:</p> \ud83e\udd16 EXAMPLE: <pre><code>--skiponfailure not-ready\n--skiponfailure experimentalANDmobile\n</code></pre> <p></p> <p>Starting from RF 5.0, the reserved tag robot:skip-on-failure can alternatively be used to achieve the same effect as above:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n    [Tags]    robot:skip-on-failure\n    Fail      this Test will be marked as skipped instead of failed\n</code></pre> <p></p> <p>The motivation for this functionality is allowing execution of tests which are not yet ready or that are executing a functionality which is not yet ready. Instead of such tests failing, they will be marked skipped and their tags can be used to separate them from possible other skipped tests.</p>"},{"location":"using/execution/#migrating-from-criticality-to-skip","title":"Migrating from criticality to SKIP","text":"<p>The first Robot Framework versions supported  criticality concept which allowed marking tests critical or non-critical. By default all tests were critical, but the --critical and --noncritical options could be used to configure that. The difference between critical and non-critical tests was that non-critical were not included when determining the final status for an executed suite or for the whole execution. In practice the Test status was two dimensional having PASS and FAIL in one axis and criticality on the other.</p> <p>Non-critical failed tests were in many ways similar to the current skipped tests. Because these features are similar and having both SKIP and criticality would have created strange statuses such as a non-critical SKIP, the criticality concept was removed in Robot Framework 4.0 when the SKIP status was introduced. The problems with criticality are explained in more detail in the issue that proposed removing it.</p> <p>The main use case for the criticality concept was being able to run tests which are not yet ready or that are executing a functionality that is not yet ready. This use case is nowadays covered by the skip-on-failure functionality discussed in the previous section.</p> <p>To ease migrating from criticality to skipping, the old --noncritical option worked as an alias for the new --skiponfailure in Robot Framework 4.0 and also the old --critical option was preserved. Both old options were deprecated and they were removed in Robot Framework 5.0.</p>"},{"location":"using/execution/#suite-status","title":"Suite status","text":"<p>Suite status is determined solely based on statuses of the tests it contains:</p> <ul> <li>If any Test has failed, suite status is FAIL.</li> <li>If there are no failures but at least one Test has passed, suite status is PASS.</li> <li>If all tests have been skipped or the are no tests at all, suite status is SKIP.</li> </ul>"},{"location":"using/execution/#continuing-on-failure","title":"Continuing on failure","text":"<p>Typically, test cases are stopped immediately when any of their keywords fail. This behavior shortens test execution time and prevents subsequent keywords hanging or otherwise causing problems if the system under test/RPA system is in unstable state. This has a drawback that often subsequent keywords would give more information about the state of the system, however, and in some cases those subsequent keywords would actually handle of the needed cleanup activities. Hence, Robot Framework offers several features to continue even if there are failures.</p>"},{"location":"using/execution/#execution-continues-on-teardowns-automatically","title":"Execution continues on teardowns automatically","text":"<p>To ensure all the cleanup activities are handled, the continue-on-failure mode is automatically enabled in suite, Test and keyword teardowns. In practice this means that in teardowns all the keywords in all levels are always executed.</p> <p>If this behavior is not desired, the special robot:stop-on-failure and robot:recursive-stop-on-failure tags can be used to disable it.</p>"},{"location":"using/execution/#all-top-level-keywords-are-executed-when-tests-have-templates","title":"All top-level keywords are executed when tests have templates","text":"<p>When using Test templates, all the top-level keywords are executed to make it sure that all the different combinations are covered. In this usage continuing is limited to the top-level keywords and inside them the execution ends normally if there are non-continuable failures.</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nContinue with templates\n    [Template]    Should be Equal\n    this    fails\n    this    is run\n</code></pre> <p></p> <p>If this behavior is not desired, the special robot:stop-on-failure and robot:recursive-stop-on-failure tags can be used to disable it.</p>"},{"location":"using/execution/#special-failures-from-keywords","title":"Special failures from keywords","text":"<p>Library keywords report failures using exceptions and it is possible to use special exceptions to inform Robot Framework that execution can continue regardless the failure. How these exceptions can be created is explained in the Continuable failures section in the Creating Test libraries section.</p> <p>When a Test ends and there have been continuable failures, the Test will be marked failed. If there is more than one failure, all of them will be enumerated in the final error message:</p> \ud83e\udd16 EXAMPLE: <pre><code>Several failures occurred:\n\n1) First error message.\n\n2) Second error message.\n</code></pre> <p></p> <p>Test execution ends also if a normal failure occurs after a continuable failure. Also in that case all the failures will be listed in the final error message.</p> <p>The return value from failed keywords, possibly assigned to a variable, is always the Python None.</p>"},{"location":"using/execution/#run-keyword-and-continue-on-failure-keyword","title":"Run Keyword And Continue On Failure keyword","text":"<p>BuiltIn keyword Run Keyword And Continue On Failure allows converting any failure into a continuable failure. These failures are handled by the framework exactly the same way as continuable failures originating from library keywords discussed above.</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n    Run Keyword and Continue on Failure    Should be Equal    1    2\n    Log    This is executed but test fails in the end\n</code></pre> <p></p>"},{"location":"using/execution/#enabling-continue-on-failure-using-tags","title":"Enabling continue-on-failure using tags","text":"<p>All keywords executed as part of test cases or user keywords which are tagged with the robot:continue-on-failure tag are considered continuable by default. For example, the following two tests behave identically:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nTest 1\n    Run Keyword and Continue on Failure    Should be Equal    1    2\n    User Keyword 1\n\nTest 2\n    [Tags]    robot:continue-on-failure\n    Should be Equal    1    2\n    User Keyword 2\n\n*** Keywords ***\nUser Keyword 1\n    Run Keyword and Continue on Failure    Should be Equal    3    4\n    Log    This is executed\n\nUser Keyword 2\n    [Tags]    robot:continue-on-failure\n    Should be Equal    3    4\n    Log    This is executed\n</code></pre> <p></p> <p>These tags also affect the continue-on-failure mode with different control structures. For example, the below test case will execute the Do Something keyword ten times regardless whether each succeeds or not:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n    [Tags]    robot:continue-on-failure\n    FOR    ${index}    IN RANGE    10\n        Do Something\n    END\n</code></pre> <p></p> <p>Setting robot:continue-on-failure within a test case or a user keyword will not propagate the continue-on-failure behavior into user keywords they call. If such recursive behavior is needed, the robot:recursive-continue-on-failure tag can be used. For example, all keywords in the following example are executed:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n    [Tags]    robot:recursive-continue-on-failure\n    Should be Equal    1    2\n    User Keyword 1\n    Log    This is executed\n\n*** Keywords ***\nUser Keyword 1\n    Should be Equal    3    4\n    User Keyword 2\n    Log    This is executed\n\nUser Keyword 2\n    Should be Equal    5    6\n    Log    This is executed\n</code></pre> <p></p> <p>Setting robot:continue-on-failure or robot:recursive-continue-on-failure in a test case does NOT alter the behaviour of a failure in the keyword(s) executed as part of the [Setup]: The test case is marked as failed and no test case keywords are executed.</p> <p>\ud83d\udce2 _NOTE: The robot:continue-on-failure and robot:recursive-continue-on-failure tags are new in Robot Framework 4.1. They do not work properly with WHILE loops prior to Robot Framework 6.0.</p>"},{"location":"using/execution/#disabling-continue-on-failure-using-tags","title":"Disabling continue-on-failure using tags","text":"<p>Special tags robot:stop-on-failure and robot:recursive-stop-on-failure can be used to disable the continue-on-failure mode if needed. They work when continue-on-failure has been enabled using tags and also with teardowns and templates:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nDisable continue-in-failure set using tags\n    [Tags]    robot:recursive-continue-on-failure\n    Keyword\n    Keyword    # This is executed\n\nDisable continue-in-failure in teardown\n    No Operation\n    [Teardown]    Keyword\n\nDisable continue-in-failure with templates\n    [Tags]    robot:stop-on-failure\n    [Template]    Should be Equal\n    this    fails\n    this    is not run\n\n*** Keywords ***\nKeyword\n    [Tags]    robot:stop-on-failure\n    Should be Equal    this    fails\n    Should be Equal    this    is not run    \n</code></pre> <p></p> <p>The robot:stop-on-failure tag affects only test cases and user keywords where it is used and does not propagate to user keywords they call nor to their own teardowns. If recursive behavior affecting all called user keywords and teardowns is desired, the robot:recursive-stop-on-failure tag can be used instead. If there is a need, its effect can again be disabled in lower level keywords by using robot:continue-on-failure or robot:recursive-continue-on-failure tags.</p> <p>The robot:stop-on-failure and robot:recursive-stop-on-failure tags do not alter the behavior of continuable failures caused by library keywords or by Run Keyword And Continue On Failure. For example, both keywords in this example are run even though robot:stop-on-failure is used:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n    [Tags]    robot:stop-on-failure\n    Run Keyword and Continue on Failure    Should be Equal    1    2\n    Log    This is executed regardless the tag    \n</code></pre> <p></p> <p>If robot:recursive-stop-on-failure and robot:continue-on-failure are used together in the same Test or keyword, execution is stopped in called keywords if there are failures, but continues in the Test or keyword using these tags. If robot:recursive-continue-on-failure and robot:stop-on-failure are used together in the same Test or keyword, execution is continued in called keywords if there are failures, but stopped in the Test or keyword using these tags.</p> <p>\ud83d\udce2 _NOTE: The robot:stop-on-failure and robot:recursive-stop-on-failure tags are new in Robot Framework 6.0.</p> <p>\ud83d\udce2 _NOTE: Using recursive and non-recursive tags together in same Test or keyword is new in Robot Framework 7.0.</p>"},{"location":"using/execution/#tryexcept","title":"TRY/EXCEPT","text":"<p>Robot Framework 5.0 introduced a native TRY/EXCEPT syntax which can be used for handling failures:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n    TRY\n        Some Keyword\n    EXCEPT    Expected error message\n        Error Handler Keyword\n    END    \n</code></pre> <p></p> <p>For more details see the separate TRY/EXCEPT syntax section.</p>"},{"location":"using/execution/#builtin-keywords","title":"BuiltIn keywords","text":"<p>There are several BuiltIn keywords that can be used to execute other keywords so that execution can continue after possible failures:</p> <ul> <li>Run Keyword And Expect Error executes a keyword and expects it to fail with the specified error message. The aforementioned TRY/EXCEPT syntax is nowadays generally recommended instead.</li> <li>Run Keyword And Ignore Error executes a keyword and silences possible error. It returns the status along with possible keyword return value or error message. The TRY/EXCEPT syntax generally works better in this case as well.</li> <li>Run Keyword And Warn On Failure is a wrapper for Run Keyword And Ignore Error that automatically logs a warning if the executed keyword fails.</li> <li>Run Keyword And Return Status executes a keyword and returns Boolean True or False depending on did it pass or fail.</li> </ul>"},{"location":"using/execution/#stopping-test-execution-gracefully","title":"Stopping test execution gracefully","text":"<p>Sometimes there is a need to stop the execution before all the tests have finished, but still with logs and reports being created. Different ways of accomplishing this are explained below. In all these cases the remaining test cases are marked failed.</p> <p>The tests which are automatically failed get robot:exit tag and the generated report will include NOT robot:exit combined tag pattern to easily see those tests which were not skipped. Note that the Test in which the exit happened does not get the robot:exit tag.</p> <p>\ud83d\udce2 _NOTE: Prior to Robot Framework 3.1, the special tag was named robot-exit.</p>"},{"location":"using/execution/#pressing-ctrl-c","title":"Pressing Ctrl-C","text":"<p>The execution is stopped when Ctrl-C is pressed in the console where the execution is occurring. The execution is stopped immediately, but reports and logs are still generated.</p> <p>If Ctrl-C is pressed again, the execution ends immediately and reports and logs are not created.</p>"},{"location":"using/execution/#using-signals","title":"Using signals","text":"<p>On UNIX-like machines it is possible to terminate execution using signals INT and TERM. These signals can be sent from the command line using a kill command and sending signals can also be easily automated.</p>"},{"location":"using/execution/#using-keywords","title":"Using keywords","text":"<p>The execution can be stopped also by the executed keywords. There is a separate Fatal Error BuiltIn keyword for this purpose, and custom keywords can use fatal exceptions when they fail.</p>"},{"location":"using/execution/#stopping-when-first-test-case-fails","title":"Stopping when first test case fails","text":"<p>If option --exitonfailure (-X) is used, execution stops immediately if any Test fails. The remaining tests are marked as failed without actually executing them.</p>"},{"location":"using/execution/#stopping-on-parsing-or-execution-error","title":"Stopping on parsing or execution error","text":"<p>Robot Framework separates failures caused by failing keywords from errors caused by, for example, invalid settings or failed library imports. By default these errors are reported as execution errors, but errors themselves do not fail tests or affect execution otherwise. If --exitonerror option is used, however, all such errors are considered fatal and execution stopped so that remaining tests are marked failed. With parsing errors encountered before execution even starts, this means that no tests are actually run.</p>"},{"location":"using/execution/#handling-teardowns","title":"Handling teardowns","text":"<p>By default teardowns of the tests and suites which have been started are executed even if the execution is stopped using one of the methods above. This allows clean-up activities to be run regardless how execution ends.</p> <p>It is also possible to skip teardowns when execution is stopped by using --skipteardownonexit option. This can be useful if, for example, clean-up tasks take a lot of time.</p>"},{"location":"using/execution/#task-execution","title":"Task execution","text":"<p>Robot Framework can be used also for other automation purposes than test automation and starting from Robot Framework 3.1 it is possible to explicitly create and execute Robotic Process Automation  tasks. For the most parts task execution and test execution work the same way and this section explains the differences.</p>"},{"location":"using/execution/#generic-automation-mode","title":"Generic automation mode","text":"<p>When Robot Framework is used execute a file and it notices that the file has tasks, not tests, it automatically sets itself into the generic automation mode. This mode does not change the actual execution at all, but when logs and reports are created, they use term task, not test. They have, for example, headers like Task Log and Task Statistics instead of Test Log and Test Statistics.</p> <p>The generic automation mode can also be enabled by using the --rpa option. In that case the executed files can have either tests or tasks. Alternatively --norpa can be used to force the test automation mode even if executed files contain tasks. If neither of these options are used, it is an error to execute multiple files so that some have tests and others have tasks.</p> <p>The execution mode is stored in the generated output file and read by Rebot if outputs are post-processed. The mode can also be set when using Rebot if necessary.</p> <p>TODO: Below reads as though the user would have read the above test section 1st perhaps. Better a clone of test for those users coming only to this section?</p>"},{"location":"using/execution/#task-related-command-line-options","title":"Task related command line options","text":"<p>All normal command line options can be used when executing tasks. If there is a need to select only certain tasks for execution, --task can be used instead of --test. Additionally the aforementioned --rpa can be used to control the execution mode.</p>"},{"location":"using/execution/#post-processing-outputs","title":"Post-processing outputs","text":"<p>XML output files that are generated during the test execution can be post-processed afterwards by the Rebot tool, which is an integral part of Robot Framework. It is used automatically when test/task reports and logs are generated during the execution and using it separately allows creating custom reports and logs as well as combining and merging results.</p>"},{"location":"using/execution/#using-rebot","title":"Using Rebot","text":"\ud83e\udd16 EXAMPLE: <pre><code>rebot [options] outputs\npython -m robot.rebot [options] outputs\npython path/to/robot/rebot.py [options] outputs\n</code></pre> <p>The most common way to use Rebot is using the rebot command. Alternatively it is possible to execute the installed robot.rebot module or the robot/rebot.py file using the selected Python interpreter.</p>"},{"location":"using/execution/#specifying-options-and-arguments","title":"Specifying options and arguments","text":"<p>The basic syntax for using Rebot is exactly the same as when starting test execution and also most of the command line options are identical. The main difference is that arguments to Rebot are XML output files instead of input data files or directories.</p>"},{"location":"using/execution/#return-codes-with-rebot","title":"Return codes with Rebot","text":"<p>Return codes from Rebot are exactly same as when running tests.</p>"},{"location":"using/execution/#controlling-execution-mode","title":"Controlling execution mode","text":"<p>Rebot notices whether tests or tasks been run and by default preserves the execution mode. The mode affects logs and reports so that in the former case they will use terminology of test, such as Test Log and Test Statistics, and in the latter case term task such as Task Log and Task Statistics.</p> <p>Rebot also supports using --rpa or --norpa options to set the execution mode explicitly. This is necessary if multiple output files are processed and they have conflicting modes.</p>"},{"location":"using/execution/#creating-reports-logs-and-output-files","title":"Creating reports, logs and output files","text":"<p>You can use Rebot for creating the same reports and logs that are created automatically during the test execution. Of course, it is not sensible to create the exactly same files, but, for example, having one report with all test cases and another with only some subset of tests can be useful:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot output.xml\nrebot path/to/output_file.xml\nrebot --include smoke --name Smoke_Tests c:\\results\\output.xml\n</code></pre> <p></p> <p>Another common usage is creating only the output file when running tests (log and report generation can be disabled with --log NONE --report NONE) and generating logs and reports later. Tests can, for example, be executed on different environments, output files collected to a central place and reports and logs created there.</p> <p>Rebot does not create XML output files by default, but it is possible to create them by using the --output (-o) option. Log and report are created by default, but they can be disabled by using value NONE (case-insensitive) if they are not needed:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot --include smoke --output smoke.xml --log none --report none original.xml\n</code></pre> <p></p>"},{"location":"using/execution/#combining-outputs","title":"Combining outputs","text":"<p>An important feature in Rebot is its ability to combine outputs from different test execution rounds. This capability allows, for example, running the same test cases/RPA tasks on different environments and generating an overall report from all outputs. Combining outputs is extremely easy, all that needs to be done is giving several output files as arguments:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot output1.xml output2.xml\nrebot outputs/*.xml   \n</code></pre> <p></p> <p>When outputs are combined, a new top-level suite is created so that suites in the given output files are its child suites. This works the same way when multiple input data files or directories are executed, and also in this case the name of the top-level suite is created by joining child suite names with an ampersand (&amp;) and spaces. These automatically generated names are not ideal, and it is often a good idea to use --name to give a more meaningful name:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot --name Browser_Compatibility firefox.xml opera.xml safari.xml ie.xml\nrebot --include smoke --name Smoke_Tests c:\\results\\*.xml\n</code></pre> <p></p>"},{"location":"using/execution/#merging-outputs","title":"Merging outputs","text":"<p>If the same tests are re-executed or a single test suite executed in pieces, combining results like discussed above creates an unnecessary top-level suite. In these cases it is typically better to merge results instead. Merging is acheived by using --merge (-R) option which changes the way how Rebot combines two or more output files. This option itself takes no arguments and all other command line options can be used with it normally:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot --merge original.xml merged.xml\nrebot --merge --name Example first.xml second.xml third.xml\n</code></pre> <p></p> <p>When suites are merged, documentation, suite setup and suite teardown are obtained from the last merged suite. Suite metadata from all merged suites is preserved so that values in latter suites have precedence.</p> <p>How merging tests works, is explained in the following sections discussing the two main merge use cases.</p> <p>\ud83d\udce2 _NOTE: Getting suite documentation and metadata from merged suites is new in Robot Framework 6.0.</p>"},{"location":"using/execution/#merging-re-executed-teststasks","title":"Merging re-executed tests/tasks","text":"<p>There is often a need to re-execute a subset of tests/tasks, for example, after fixing a bug in the system under test/RPA system or in the tests/tasks themselves. This can be accomplished by selecting test cases/tasks by names (--test or --task and --suite options), tags (--include and --exclude), or by previous status (--rerunfailed or --rerunfailedsuites).</p> <p>Combining re-execution results with the original results using the default combining outputs approach does not work too well. The main problem is that you get separate suites and possibly already fixed failures are also shown. In this situation it is better to use the --merge (-R) option to tell Rebot to merge the results instead. In practice this means that tests/tasks from the latter test/task runs replace those in the original. An exception to this rule is that skipped tests/tasks  in latter runs are ignored and the original are preserved.</p> <p>This usage is best illustrated by a practical example using --rerunfailed and --merge together:</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --output original.xml tests                          # first execute all tests\nrobot --rerunfailed original.xml --output rerun.xml tests  # then re-execute failing\nrebot --merge original.xml rerun.xml                       # finally merge results\n</code></pre> <p></p> <p>The message of the merged tests/tasks contains a note that results have been replaced. The message also shows the old status and message of the test/task.</p> <p>Merged results must always have same top-level suite. Tests/tasks and suites in merged outputs that are not found from the original output, are added into the resulting output. How this works in practice is discussed in the next section.</p> <p>\ud83d\udce2 _NOTE: Ignoring skipped tests in latter runs is new in Robot Framework 4.1.</p>"},{"location":"using/execution/#merging-suites-executed-in-pieces","title":"Merging suites executed in pieces","text":"<p>Another important use case for the --merge option is merging results got when running a suite in pieces using, for example, --include and --exclude options:</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --include smoke --output smoke.xml tests   # first run some tests\nrobot --exclude smoke --output others.xml tests  # then run others\nrebot --merge smoke.xml others.xml               # finally merge results\n</code></pre> <p></p> <p>When merging outputs like this, the resulting output contains all tests/tasks and suites found from all given output files. If some test/task is found from multiple outputs, latest results replace the earlier ones as explained in the previous section. Also this merging strategy requires the top-level suites to be same in all outputs.</p>"},{"location":"using/execution/#json-output-files","title":"JSON output files","text":"<p>Rebot can create and process output files also in the JSON format. Creating JSON output files is done using the typical --output option so that the specified file has a .json extension:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot --output output.json output.xml   \n</code></pre> <p></p> <p>When reading output files, JSON files are automatically recognized by the extension:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot output.json\nrebot output1.json output2.json\n</code></pre> <p></p> <p>When combining or merging results, it is possible to mix JSON and XML files:</p> \ud83e\udd16 EXAMPLE: <pre><code>rebot output1.xml output2.json\nrebot --merge original.xml rerun.json\n</code></pre> <p></p> <p>The JSON output file structure is documented in the result.json schema file.</p> <p>\ud83d\udce2 _NOTE: Support for JSON output files is new in Robot Framework 7.0.</p>"},{"location":"using/execution/#configuring-execution","title":"Configuring execution","text":"<p>This section explains different command line options that can be used for configuring the execution or post-processing outputs. Options related to generated output files are discussed in the next section.</p>"},{"location":"using/execution/#selecting-files-to-parse","title":"Selecting files to parse","text":""},{"location":"using/execution/#executing-individual-files","title":"Executing individual files","text":"<p>When executing individual files, Robot Framework tries to parse and run them regardless the name or the file extension. Which parser to use depends on the extension:</p> <ul> <li>.robot files and files that are not recognized are parsed using the normal Robot Framework parser.</li> <li>.rst and .rest files are parsed using the reStructuredText parser.</li> <li>.rbt and .json files are parsed using the JSON parser.</li> </ul> <p>Files supported by custom parsers are parsed by a matching parser.</p> \ud83e\udd16 EXAMPLES: <pre><code>robot example.robot    # Standard Robot Framework parser.\nrobot example.tsv      # Must be compatible with the standard parser.\nrobot example.rst      # reStructuredText parser.\nrobot x.robot y.rst    # Parse both files using an appropriate parser.\n</code></pre> <p></p>"},{"location":"using/execution/#included-and-excluded-files","title":"Included and excluded files","text":"<p>When executing a directory, files and directories are parsed using the following rules:</p> <ul> <li>All files and directories starting with a dot (.) or an underscore (_) are ignored.</li> <li>.robot files are parsed using the normal Robot Framework parser.</li> <li>.robot.rst files are parsed using the reStructuredText parser.</li> <li>.rbt files are parsed using the JSON parser.</li> <li>Files supported by custom parsers are parsed by a matching parser.</li> <li>Other files are ignored unless parsing them has been enabled by using the --parseinclude or --extension options discussed in the subsequent sections.</li> </ul>"},{"location":"using/execution/#selecting-files-by-name-or-path","title":"Selecting files by name or path","text":"<p>When executing a directory, it is possible to parse only certain files based on their name or path by using the --parseinclude (-I) option. This option has slightly different semantics depending on the value it is used with:</p> <p>If the value is just a file name like example.robot, files matching the name in all directories will be parsed. To match only a certain file in a certain directory, files can be given as relative or absolute paths like path/to/tests.robot. If the value is a path to a directory, all files inside that directory are parsed, recursively.</p> \ud83e\udd16 EXAMPLES: <pre><code>robot --parseinclude example.robot tests       # Parse `example.robot` files anywhere under `tests`.\nrobot -I example_*.robot -I ???.robot tests    # Parse files matching `example_*.robot` or `???.robot` under `tests`.\nrobot -I tests/example.robot tests             # Parse only `tests/example.robot`.\nrobot --parseinclude tests/example tests       # Parse files under `tests/example` directory, recursively.\n</code></pre> <p></p> <p>Values used with --parseinclude are case-insensitive and support glob patterns like example_*.robot. There are, however, two small differences compared to how patterns typically work with Robot Framework:</p> <ul> <li>* matches only a single path segment. For example, path/*/tests.robot matches path/to/tests.robot but not path/to/nested/tests.robot.</li> <li>* can be used to enable recursive matching. For example, path/*/tests.robot matches both path/to/tests.robot and path/to/nested/tests.robot.</li> </ul> <p>If the pattern contains a file extension, files with that extension are parsed even if they by default would not be. Which parser to use depends on the used extension:</p> <ul> <li>.rst and .rest files are parsed using the reStructuredText parser.</li> <li>.json files are parsed using the JSON parser.</li> <li>Other files are parsed using the normal Robot Framework parser.</li> </ul> <p>Notice that when you use a pattern such as .robot and a file exists which that matches the pattern in the execution directory, the shell may resolve the pattern before Robot Framework is called and the value passed to it is the file name, not the original pattern. In such cases you need to quote or escape the pattern like '.robot' or *.robot.</p> <p>\ud83d\udce2 _NOTE: --parseinclude is new in Robot Framework 6.1.</p>"},{"location":"using/execution/#selecting-files-by-extension","title":"Selecting files by extension","text":"<p>In addition to using the --parseinclude option discussed in the previous section, it is also possible to enable parsing files that are not parsed by default by using the --extension (-F) option. Matching extensions is case insensitive and the preceeding dot can be omitted. If there is a need to parse more than one kind of file, it is possible to use a colon : to separate extensions:</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --extension rst path/to/tests    # Parse only *.rst files.\nrobot -F robot:rst path/to/tests       # Parse *.robot and *.rst files.\n</code></pre> <p></p> <p>The above is equivalent to the following --parseinclude usage:</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --parseinclude *.rst path/to/tests\nrobot -I *.robot -I *.rst path/to/tests\n</code></pre> <p></p> <p>Because the --parseinclude option is more powerful and covers all same use cases as the --extension option, the latter is likely to be deprecated in the future. Users are recommended to use --parseinclude already now.</p>"},{"location":"using/execution/#using-custom-parsers","title":"Using custom parsers","text":"<p>External parsers can parse files that Robot Framework does not recognize otherwise. For more information about creating and using such parsers see the Parser interface section.</p>"},{"location":"using/execution/#selecting-test-casesrpa-tasks","title":"Selecting test cases/RPA tasks","text":"<p>Robot Framework offers several command line options for selecting which test cases to execute. The same options work also when executing tasks and when post-processing outputs with Rebot.</p>"},{"location":"using/execution/#by-test-names","title":"By test names","text":"<p>The easiest way to select only some tests/tasks to be run is using the --test (-t) option. As the name implies, it can be used for selecting tests/tasks by their names. Given names are case, space and underscore insensitive and they also support simple patterns. The option can be used multiple times to match multiple tests/tasks:</p> \ud83e\udd16 EXAMPLE: <pre><code>--test Example                   # Match only tests with name 'Example'.\n--test example*                  # Match tests starting with 'example'.\n--test first --test second       # Match tests with name 'first' or 'second'.\n</code></pre> <p></p> <p>To pinpoint a test more precisely, it is possible to prefix the test/task name with a suite name:</p> \ud83e\udd16 EXAMPLE: <pre><code>--test mysuite.mytest            # Match test 'mytest' in suite 'mysuite'.\n--test root.sub.test             # Match test 'test' in suite 'sub' in suite 'root'.\n--test *.sub.test                # Match test 'test' in suite 'sub' anywhere.\n</code></pre> <p></p> <p>Notice that when the given name includes a suite name, it must match the whole suite name starting from the root suite. Using a wildcard as in the last example above allows matching tests/tasks with a parent suite anywhere.</p> <p>Using the --test option is convenient when only a few tests needs to be selected. A common use case is running just the test/task that is currently being worked on. If a bigger number of tests needs to be selected, it is typically easier to select them by suite names or by tag names.</p> <p>When executing tasks, it is possible to use the --task option as an alias for --test.</p>"},{"location":"using/execution/#by-suite-names","title":"By suite names","text":"<p>Tests/tasks can be selected also by suite names with the --suite (-s) option that selects all tests/tasks in matching suites. Similarly as with --test or --task, given names are case, space and underscore insensitive and support simple patterns. To pinpoint a suite more precisely, it is possible to prefix the name with the parent suite name:</p> \ud83e\udd16 EXAMPLE: <pre><code>--suite Example                  # Match only suites with name 'Example'.\n--suite example*                 # Match suites starting with 'example'.\n--suite first --suite second     # Match suites with name 'first' or 'second'.\n--suite root.child               # Match suite 'child' in root suite 'root'.\n--suite *.parent.child           # Match suite 'child' with parent 'parent' anywhere.\n</code></pre> <p></p> <p>If the name contains a parent suite name, it must match the whole suite name the same way as with --test or --task. Using a wildcard as in the last example above allows matching suites with a parent suite anywhere.</p> <p>\ud83d\udce2 _NOTE: Prior to Robot Framework 7.0, --suite with a parent suite did not need to match the whole suite name. For example, parent.child would match suite child with parent parent anywhere. The name must be prefixed with a wildcard if this behavior is desired nowadays.</p> <p>If both --suite and --test options are used, only the specified tests in specified suites are selected:</p> \ud83e\udd16 EXAMPLE: <pre><code>--suite mysuite --test mytest    # Match test 'mytest' if its inside suite 'mysuite'.\n</code></pre> <p></p> <p>Using the --suite option is more or less the same as executing the appropriate suite file or directory directly. The main difference is that if a file or directory is run directly, possible suite setups and teardowns on higher level are not executed:</p> \ud83e\udd16 EXAMPLE: <pre><code># Root suite is 'Tests' and its possible setup and teardown are run.\nrobot --suite example path/to/tests\n\n# Root suite is 'Example' and possible higher level setups and teardowns are ignored.\nrobot path/to/tests/example.robot\n</code></pre> <p></p> <p>Prior to Robot Framework 6.1, files not matching the --suite option were not parsed at all for performance reasons. This optimization was not possible anymore after suites got a new Name setting that can override the default suite name that is got from the file or directory name. New --parseinclude option has been added to explicitly select which files are parsed if this kind of parsing optimization is needed.</p>"},{"location":"using/execution/#by-tag-names","title":"By tag names","text":"<p>It is possible to include and exclude test cases by tag names with the --include (-i) and --exclude (-e) options, respectively. If the --include option is used, only test cases/RPA tasks having a matching tag are selected, and with the --exclude option those having a matching tag are not. If both are used, only tests/tasks with a tag matching the former option, and not with a tag matching the latter, are selected:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include example\n--exclude not_ready\n--include regression --exclude long_lasting\n</code></pre> <p></p> <p>Both --include and --exclude can be used several times to match multiple tags. In that case a test/task is selected if it has a tag that matches any included tags, and also has no tag that matches any excluded tags.</p> <p>In addition to specifying a tag to match fully, it is possible to use tag patterns where * and ? are wildcards and AND, OR, and NOT operators can be used for combining individual tags or patterns together:</p> \ud83e\udd16 EXAMPLE: <pre><code>--include feature-4?\n--exclude bug*\n--include fooANDbar\n--exclude xxORyyORzz\n--include fooNOTbar\n</code></pre> <p></p> <p>Starting from RF 5.0, it is also possible to use the reserved tag robot:exclude to achieve the same effect as with using the --exclude option:</p> \ud83e\udd16 EXAMPLE: <pre><code>*** Test Cases ***\nExample\n   [Tags]    robot:exclude\n   Fail      This is not executed\n</code></pre> <p></p> <p>Selecting test cases/RPA tasks by tags is a very flexible mechanism and allows many interesting possibilities:</p> <ul> <li>A subset of tests to be executed before other tests, often called smoke tests, can be tagged with smoke and executed with --include smoke.</li> <li>Unfinished tests/tasks can be committed to version control with a tag such as not_ready and excluded from the execution with --exclude not_ready.</li> <li>Tests/tasks can be tagged with sprint-, where  specifies the number of the current sprint, and after executing all test cases/RPA tasks, a separate report containing only the tests/tasks for a certain sprint can be generated (for example, rebot --include sprint-42 output.xml). <p>Options --include and --exclude can be used in combination with --suite and --test or --task discussed in the previous section. In that case tests/task which are selected must match all selection criteria:</p> \ud83e\udd16 EXAMPLE: <pre><code>--suite example --include tag    # Match test if it is in suite 'example' and has tag 'tag'.\n--suite example --exclude tag    # Match test if it is in suite 'example' and does not have tag 'tag'.\n--test ex* --include tag         # Match test if its name starts with 'ex' and it has tag 'tag'.\n--test ex* --exclude tag         # Match test if its name starts with 'ex' and it does not have tag 'tag'.\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: In Robot Framework 7.0 --include and --test were cumulative and selected tests/tasks needed to match only either of these options. That behavior caused backwards incompatibility problems and it was changed back to the original already in Robot Framework 7.0.1.</p>"},{"location":"using/execution/#re-executing-failed-test-casesrpa-tasks","title":"Re-executing failed test cases/RPA tasks","text":"<p>Command line option --rerunfailed (-R) can be used to select all failed tests/tasks from an earlier output file for re-execution. This option is useful, for example, if running all tests/tasks takes a lot of time and one wants to iteratively fix failing test cases/RPA tasks.</p> \ud83e\udd16 EXAMPLE: <pre><code>robot tests                             # first execute all tests\nrobot --rerunfailed output.xml tests    # then re-execute failing\n</code></pre> <p></p> <p>Behind the scenes this option selects the failed tests/tasks as they would have been selected individually using the --test or --task option. It is possible to further fine-tune the list of selected tests by using --test, --task, --suite, --include and --exclude options.</p> <p>It is an error if the output contains no failed tests/tasks, but this behavior can be changed by using the --runemptysuite option discussed below. Using an output not originating from executing the same tests/tasks which are run now causes undefined results. Using a special value NONE as the output is same as not specifying this option at all.</p> <p>\ud83d\udce2 _TIP: Re-execution results and original results can be merged together using the --merge command line option.</p>"},{"location":"using/execution/#re-executing-failed-test-suites","title":"Re-executing failed test suites","text":"<p>Command line option --rerunfailedsuites (-S) can be used to select all failed suites from an earlier output file for re-execution. Like --rerunfailed (-R), this option is useful when full test execution takes a lot of time. Note that all tests/tasks from a failed suite will be re-executed, even passing ones. This option is useful when the tests/tasks in a suite depend on each other.</p> <p>Behind the scenes this option selects the failed suites as they would have been selected individually with the --suite option. It is possible to further fine-tune the list of selected tests/tasks by using --test, --task, --suite, --include and --exclude options.</p>"},{"location":"using/execution/#when-no-tests-match-selection","title":"When no tests match selection","text":"<p>By default when no tests match the selection criteria test execution fails with an error such as:</p> \ud83e\udd16 EXAMPLE: <pre><code>[ ERROR ] Suite 'Example' contains no tests matching tag 'xxx'.\n</code></pre> <p></p> <p>Because no outputs are generated, this behavior can be problematic if tests/tasks are executed and results processed automatically. Luckily a command line option --RunEmptySuite (case-insensitive) can be used to force the suite to be executed also in this case. As a result normal outputs are created but show zero executed tests/tasks. The same option can be used also to alter the behavior when an empty directory or a test case/RPA task file containing no tests/tasks is executed.</p> <p>A similar situation can occur also when processing output files with Rebot. It is possible that no tests/tasks match the used filtering criteria or that the output file contained no tests/tasks to begin with. By default executing Rebot fails in these cases, but it has a separate --ProcessEmptySuite option that can be used to alter the behavior. In practice this option works the same way as --RunEmptySuite when running tests.</p> <p>\ud83d\udce2 _NOTE: Using --RunEmptySuite with --ReRunFailed or --ReRunFailedSuites requires Robot Framework 5.0.1 or newer.</p>"},{"location":"using/execution/#setting-metadata","title":"Setting metadata","text":""},{"location":"using/execution/#setting-suite-name","title":"Setting suite name","text":"<p>When Robot Framework parses input data, suite names are created from file and directory names. The name of the top-level suite can, however, be overridden with the command line option --name (-N):</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --name \"Custom name\" tests.robot\n</code></pre> <p></p>"},{"location":"using/execution/#setting-suite-documentation","title":"Setting suite documentation","text":"<p>In addition to defining documentation in the input data, documentation of the top-level suite can be given from the command line with the option --doc (-D). The value can contain simple HTML formatting and must be quoted if it contains spaces.</p> <p>If the given documentation is a relative or absolute path pointing to an existing file, the actual documentation will be read from that file. This is especially convenient if the externally specified documentation is long or contains multiple lines.</p> \ud83e\udd16 EXAMPLES: <pre><code>robot --doc \"Example documentation\" tests.robot\nrobot --doc doc.txt tests.robot    # Documentation read from doc.txt if it exits.\n</code></pre> <p></p> <p>\ud83d\udce2 NOTE: Reading documentation from an external file is new in Robot Framework 4.1. \ud83d\udce2 NOTE: Prior to Robot Framework 3.1, underscores in documentation were converted to spaces same way as with the --name option.</p>"},{"location":"using/execution/#setting-free-suite-metadata","title":"Setting free suite metadata","text":"<p>Free suite metadata may also be given from the command line with the option --metadata (-M). The argument must be in the format name:value, where name the name of the metadata to set and value is its value. The value can contain simple HTML formatting and the whole argument must be quoted if it contains spaces. This option may be used several times to set multiple metadata values.</p> <p>If the given value is a relative or absolute path pointing to an existing file, the actual value will be read from that file. This is especially convenient if the value is long or contains multiple lines. If the value should be a path to an existing file, not read from that file, the value must be separated with a space from the name: part.</p> \ud83e\udd16 EXAMPLES: <pre><code>robot --metadata Name:Value tests.robot\nrobot --metadata \"Another Name:Another value, now with spaces\" tests.robot\nrobot --metadata \"Read From File:meta.txt\" tests.robot    # Value read from meta.txt if it exists.\nrobot --metadata \"Path As Value: meta.txt\" tests.robot    # Value always used as-is.\n</code></pre> <p></p> <p>\ud83d\udce2 NOTE: Reading metadata value from an external file is new in Robot Framework 4.1. \ud83d\udce2 NOTE: Prior to Robot Framework 3.1, underscores in the value were converted to spaces same way as with the --name option.</p>"},{"location":"using/execution/#setting-testtask-tags","title":"Setting test/task tags","text":"<p>The command line option --settag (-G) can be used to set the given tag to all executed test cases/RPA tasks. This option may be used several times to set multiple tags.</p>"},{"location":"using/execution/#configuring-where-to-search-libraries-and-other-extensions","title":"Configuring where to search libraries and other extensions","text":"<p>When Robot Framework imports a library, listener, or some other Python based extension, it uses the Python interpreter to import the module containing the extension from the system. The list of locations where modules are looked for is called the module search path, and its contents can be configured using different approaches explained in this section.</p> <p>Robot Framework uses Python's module search path also when importing resource and variable files if the specified path does not match any file directly.</p> <p>The module search path being set correctly so that libraries and other extensions are found is a requirement for successful execution. If you need to customize it using approaches explained below, it is often a good idea to create a custom start-up script.</p>"},{"location":"using/execution/#locations-automatically-in-module-search-path","title":"Locations automatically in module search path","text":"<p>Python interpreters have their own standard library as well as a directory where third party modules are installed automatically in the module search path. This means that libraries packaged using Python's own packaging system are automatically installed so that they can be imported without any additional configuration.</p>"},{"location":"using/execution/#pythonpath","title":"PYTHONPATH","text":"<p>Python reads additional locations to be added to the module search path from PYTHONPATH environment variables. If you want to specify more than one location in any of them, you need to separate the locations with a colon on UNIX-like machines (e.g. /opt/libs:$HOME/testlibs) and with a semicolon on Windows (e.g. D:\\libs;%HOMEPATH%\\testlibs).</p> <p>Environment variables can be configured permanently system wide or so that they affect only a certain user. Alternatively they can be set temporarily before running a command, something which works extremely well in custom start-up scripts.</p>"},{"location":"using/execution/#using-pythonpath-option","title":"Using --pythonpath option","text":"<p>Robot Framework has a separate command line option --pythonpath (-P) for adding locations to the module search path.</p> <p>Multiple locations can be given by separating them with a colon (:) or a semicolon (;) or by using this option multiple times. If the value contains both colons and semicolons, it is split from semicolons. Paths can also be glob patterns matching multiple paths, but they typically need to be escaped when used on the console.</p> \ud83e\udd16 EXAMPLES: <pre><code>--pythonpath libs\n--pythonpath /opt/testlibs:mylibs.zip:yourlibs\n--pythonpath /opt/testlibs --pythonpath mylibs.zip --pythonpath yourlibs\n--pythonpath c:\\temp;d:\\resources\n--pythonpath  lib/\\*.zip    # '*' is escaped\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: Both colon and semicolon work regardless the operating system. Using semicolon is new in Robot Framework 5.0.</p>"},{"location":"using/execution/#configuring-syspath-programmatically","title":"Configuring sys.path programmatically","text":"<p>Python interpreters store the module search path they use as a list of strings in sys.path attribute. This list can be updated dynamically during execution and changes are taken into account the next time when something is imported.</p>"},{"location":"using/execution/#setting-variables","title":"Setting variables","text":"<p>Variables can be set from the command line either individually using the --variable (-v) option or through variable files with the --variablefile (-V) option. Variables and variable files are explained in separate chapters, but the following examples illustrate how to use these options:</p> \ud83e\udd16 EXAMPLES: <pre><code>--variable name:value\n--variable OS:Linux --variable IP:10.0.0.42\n--variablefile path/to/variables.py\n--variablefile myvars.py:possible:arguments:here\n--variable ENVIRONMENT:Windows --variablefile c:\\resources\\windows.py\n</code></pre> <p></p>"},{"location":"using/execution/#dry-run","title":"Dry run","text":"<p>Robot Framework supports a so-called dry run mode where the tests/tasks are run normally otherwise, but the keywords coming from the libraries are not executed at all. The dry run mode can be used to validate the input data; if the dry run passes, the data should be syntactically correct. This mode is triggered using option --dryrun.</p> <p>The dry run execution may fail for following reasons:</p> <ul> <li>Using keywords that are not found.</li> <li>Using keywords with wrong number of arguments.</li> <li>Using user keywords that have invalid syntax.</li> </ul> <p>In addition to these failures, normal execution errors are shown, for example, when test library or resource file imports cannot be resolved.</p> <p>It is possible to disable dry run validation of specific user keywords by adding a special robot:no-dry-run keyword tag to them. This is useful if a keyword fails in the dry run mode for some reason, but work fine when executed normally.</p> <p>\ud83d\udce2 _NOTE: The dry run mode does not validate variables.</p>"},{"location":"using/execution/#randomizing-execution-order","title":"Randomizing execution order","text":"<p>The execution order can be randomized using option --randomize [:], where  is one of the following: <ul> <li><code>tests</code> Test cases inside each test suite are executed in random order.</li> <li><code>tasks</code> RPA tasks inside each suite are executed in random order.</li> <li><code>suites</code> All suites are executed in a random order, but test cases/RPA tasks inside suites are run in the order they are defined.</li> <li><code>all</code> Both test cases/RPA tasks and suites are executed in a random order.</li> <li><code>none</code> Neither execution order of test/task nor suites is randomized. This value can be used to override the earlier value set with --randomize. It is possible to give a custom seed to initialize the random generator. This is useful if you want to re-run tests/tasks using the same order as earlier. The seed is given as part of the value for --randomize in format : and it must be an integer. If no seed is given, it is generated randomly. The executed top level suite automatically gets metadata named Randomized that tells both what was randomized and what seed was used. \ud83e\udd16 EXAMPLE: <pre><code>robot --randomize tests my_test.robot\nrobot --randomize all:12345 path/to/tests\n</code></pre> <p></p>"},{"location":"using/execution/#programmatic-modification-of-input-data","title":"Programmatic modification of input data","text":"<p>If the provided built-in features to modify input data before execution are not enough, Robot Framework makes it possible to perform  custom modifications programmatically. This is accomplished by creating a so called pre-run modifier and activating it using the --prerunmodifier option.</p> <p>Pre-run modifiers should be implemented as visitors that can traverse through the executable suite structure and modify it as needed. The visitor interface is explained as part of the Robot Framework API documentation and it is possible to modify executed suites, test cases/RPA tasks and keywords using it. The examples below are provided to give an idea of how pre-run modifiers can be used and how powerful this functionality is.</p> <p>When a pre-run modifier is taken into use on the command line using the --prerunmodifier option, it can be specified either as a name of the modifier class or a path to the modifier file. If the modifier is given as a class name, the module containing the class must be in the module search path, and if the module name is different than the class name, the given name must include both like module.ModifierClass. If the modifier is given as a path, the class name must be same as the file name. For most parts this works the same as  when importing a library.</p> <p>If a modifier requires arguments, as the examples below do, they can be specified after the modifier name or path using either a colon (:) or a semicolon (;) as a separator. If both are used in the value, the one used first is considered to be the actual separator. Starting from Robot Framework 4.0, arguments also support the named argument syntax as well as argument conversion based on type hints and default values the same way as keywords do.</p> <p>If more than one pre-run modifier is needed, they can be specified by using the --prerunmodifier option multiple times. If similar modifying is needed before creating logs and reports, programmatic modification of results can be enabled using the --prerebotmodifier option.</p> <p>Pre-run modifiers are executed before other configuration affecting the executed suite and test cases/RPA tasks. Most importantly, options related to selecting test cases are processed after modifiers, making it possible to use options such as --include also with possible dynamically added tests.</p> <p>\ud83d\udce2 _TIP: Modifiers are taken into use from the command line exactly the same way as listeners. See the Registering listeners from command line section for more information and examples.</p> <p>The first example below shows how a pre-run modifier can remove tests from the executed test suite structure. In this example only every Xth tests is preserved, and the X is given from the command line along with an optional start index.</p> \ud83e\udd16 EXAMPLE: Select every Xth test <pre><code>\"\"\"Pre-run modifier that selects only every Xth test for execution.\n\nStarts from the first test by default. Tests are selected per suite.\n\"\"\"\n\nfrom robot.api import SuiteVisitor\n\n\nclass SelectEveryXthTest(SuiteVisitor):\n\n    def __init__(self, x: int, start: int = 0):\n        self.x = x\n        self.start = start\n\n    def start_suite(self, suite):\n        \"\"\"Modify suite's tests to contain only every Xth.\"\"\"\n        suite.tests = suite.tests[self.start::self.x]\n\n    def end_suite(self, suite):\n        \"\"\"Remove suites that are empty after removing tests.\"\"\"\n        suite.suites = [s for s in suite.suites if s.test_count &gt; 0]\n\n    def visit_test(self, test):\n        \"\"\"Avoid visiting tests and their keywords to save a little time.\"\"\"\n        pass\n</code></pre> <p></p> <p>If the above pre-run modifier is in a file SelectEveryXthTest.py and the file is in the module search path, it could be used like this:</p> \ud83e\udd16 EXAMPLE: <pre><code># Specify the modifier as a path. Run every second test.\nrobot --prerunmodifier path/to/SelectEveryXthTest.py:2 tests.robot\n\n# Specify the modifier as a name. Run every third test, starting from the second.\nrobot --prerunmodifier SelectEveryXthTest:3:1 tests.robot\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: Argument conversion based on type hints such as x: int in the above example is new in Robot Framework 4.0 and requires Python 3.</p> <p>This second example removes tests, this time based on a given name pattern. In practice it works as a negative version of the built-in --test option.</p> \ud83e\udd16 EXAMPLE: Exclude tests by name <pre><code>\"\"\"Pre-run modifier that excludes tests by their name.\n\nTests to exclude are specified by using a pattern that is both case and space\ninsensitive and supports '*' (match anything) and '?' (match single character)\nas wildcards.\n\"\"\"\n\nfrom robot.api import SuiteVisitor\nfrom robot.utils import Matcher\n\n\nclass ExcludeTests(SuiteVisitor):\n\n    def __init__(self, pattern):\n        self.matcher = Matcher(pattern)\n\n    def start_suite(self, suite):\n        \"\"\"Remove tests that match the given pattern.\"\"\"\n        suite.tests = [t for t in suite.tests if not self._is_excluded(t)]\n\n    def _is_excluded(self, test):\n        return self.matcher.match(test.name) or self.matcher.match(test.longname)\n\n    def end_suite(self, suite):\n        \"\"\"Remove suites that are empty after removing tests.\"\"\"\n        suite.suites = [s for s in suite.suites if s.test_count &gt; 0]\n\n    def visit_test(self, test):\n        \"\"\"Avoid visiting tests and their keywords to save a little time.\"\"\"\n        pass\n</code></pre> <p></p> <p>Assuming the above modifier is in a file named ExcludeTests.py, it could be used like this:</p> \ud83e\udd16 EXAMPLE: <pre><code># Exclude test named 'Example'.\nrobot --prerunmodifier path/to/ExcludeTests.py:Example tests.robot\n\n# Exclude all tests ending with 'something'.\nrobot --prerunmodifier path/to/ExcludeTests.py:*something tests.robot\n</code></pre> <p></p> <p>Sometimes when debugging, it can be useful to disable setups or teardowns. This can be accomplished by editing the input data, but pre-run modifiers make it easy to do that temporarily for a single run:</p> \ud83e\udd16 EXAMPLE: Disable setups and teardowns <pre><code>\"\"\"Pre-run modifiers for disabling suite and test setups and teardowns.\"\"\"\n\nfrom robot.api import SuiteVisitor\n\n\nclass SuiteSetup(SuiteVisitor):\n\n    def start_suite(self, suite):\n        suite.setup = None\n\n\nclass SuiteTeardown(SuiteVisitor):\n\n    def start_suite(self, suite):\n        suite.teardown = None\n\n\nclass TestSetup(SuiteVisitor):\n\n    def start_test(self, test):\n        test.setup = None\n\n\nclass TestTeardown(SuiteVisitor):\n\n    def start_test(self, test):\n        test.teardown = None\n</code></pre> <p></p> <p>Assuming that the above modifiers are all in a file named disable.py and this file is in the module search path, setups and teardowns could be disabled, for example, as follows:</p> \ud83e\udd16 EXAMPLE: <pre><code># Disable suite teardowns.\nrobot --prerunmodifier disable.SuiteTeardown tests.robot\n\n# Disable both test setups and teardowns by using '--prerunmodifier' twice.\nrobot --prerunmodifier disable.TestSetup --prerunmodifier disable.TestTeardown tests.robot\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: Prior to Robot Framework 4.0 setup and teardown were accessed via the intermediate keywords attribute and, for example, suite setup was disabled like suite.keywords.setup = None.</p>"},{"location":"using/execution/#controlling-console-output","title":"Controlling console output","text":"<p>There are various command line options to control how execution is reported on the console.</p>"},{"location":"using/execution/#console-output-type","title":"Console output type","text":"<p>The overall console output type is set with the --console option. It supports the following case-insensitive values:</p> <ul> <li><code>verbose</code> Every suite and test case/RPA task is reported individually. This is the default.</li> <li><code>dotted</code> Only show . for passed test/tasks, F for failed, s for skipped and x for those which are skipped because of  execution exit. Failed tests/tasks are listed separately after execution. This output type makes it easy to see if there were any failures during execution even if there would be a lot of tests/tasks.</li> <li><code>quiet</code> No output except for errors and warnings.</li> <li><code>none</code> No output whatsoever. Useful when creating a custom output using, for example, listeners. Separate convenience options --dotted (-.) and --quiet are shortcuts for --console dotted and --console quiet, respectively.</li> </ul> \ud83e\udd16 EXAMPLES: <pre><code>robot --console quiet tests.robot\nrobot --dotted tests.robot\n</code></pre> <p></p>"},{"location":"using/execution/#console-width","title":"Console width","text":"<p>The width of the test execution output in the console can be set using the option --consolewidth (-W). The default width is 78 characters.</p> <p>\ud83d\udce2 _TIP: On many UNIX-like machines you can use handy $COLUMNS environment variable like --consolewidth $COLUMNS.</p>"},{"location":"using/execution/#console-colors","title":"Console colors","text":"<p>The --consolecolors (-C) option is used to control whether colors should be used in the console output. Colors are implemented using ANSI colors except on Windows where, by default, Windows APIs are used instead.</p> <p>This option supports the following case-insensitive values:</p> <ul> <li><code>auto</code> Colors are enabled when outputs are written into the console, but not when they are redirected into a file or elsewhere. This is the default.</li> <li><code>on</code> Colors are used also when outputs are redirected. Does not work on Windows.</li> <li><code>ansi</code> Same as on but uses ANSI colors also on Windows. Useful, for example, when redirecting output to a program that understands ANSI colors.</li> <li><code>off</code> Colors are disabled.</li> </ul>"},{"location":"using/execution/#console-markers","title":"Console markers","text":"<p>Special markers . (success) and F (failure) are shown on the console when using the verbose output and top level keywords in test cases/RPA tasks end. The markers allow following the execution in high level, and they are erased when test cases/RPA tasks end.</p> <p>It is possible to configure when markers are used with --consolemarkers (-K) option. It supports the following case-insensitive values:</p> <ul> <li><code>auto</code> Markers are enabled when the standard output is written into the console, but not when it is redirected into a file or elsewhere. This is the default.</li> <li><code>on</code> Markers are always used.</li> <li><code>off</code> Markers are disabled.</li> </ul>"},{"location":"using/execution/#setting-listeners","title":"Setting listeners","text":"<p>Listeners can be used to monitor the test execution. When they are taken into use from the command line, they are specified using the --listener command line option. The value can either be a path to a listener or a listener name. See the Listener interface section for more details about importing listeners and using them in general.</p>"},{"location":"using/execution/#output-files","title":"Output files","text":"<p>Several output files are created when tests/tasks are executed and all of them are somehow related to test/task results. This section discusses what outputs are created, how to configure where they are created, and how to fine-tune their contents.</p>"},{"location":"using/execution/#different-output-files","title":"Different output files","text":"<p>This section explains which different output files can be created and how to configure where they are created. Output files are configured using command line options, which get the path to the output file in question as an argument. A special value NONE (case-insensitive) can be used to disable creating a certain output file.</p>"},{"location":"using/execution/#output-directory","title":"Output directory","text":"<p>All output files can be set using an absolute path, in which case they are created to the specified place, but in other cases, the path is considered relative to the output directory. The default output directory is the directory where the execution is started from, but it can be altered with the --outputdir (-d) option. The path set with this option is, again, relative to the execution directory, but can naturally be given also as an absolute path. Regardless of how a path to an individual output file is obtained, its parent directory is created automatically, if it does not exist already.</p>"},{"location":"using/execution/#output-file","title":"Output file","text":"<p>Output files contain all the test/task execution results in machine readable XML format. Log, report and xUnit files are typically generated based on them, and they can also be combined and otherwise post-processed with Rebot.</p> <p>\ud83d\udce2 _TIP: Generating report and xUnit files as part of execution does not require processing output files after execution. Disabling log generation when running tests can thus save memory.</p> <p>The command line option --output (-o) determines the path where the output file is created relative to the output directory. The default name for the output file, when tests are run, is output.xml.</p> <p>When post-processing outputs with Rebot, new output files are not created unless the --output option is explicitly used.</p> <p>It is possible to disable creation of the output file when running tests/tasks by giving a special value NONE to the --output option. If no outputs are needed, they should all be explicitly disabled using --output NONE --report NONE --log NONE.</p> <p>The XML output file structure is documented in the robot.xsd schema file.</p> <p>\ud83d\udce2 _NOTE: Starting from Robot Framework 7.0, Rebot can read and write JSON output files. The plan is to enhance the support for JSON output files in the future so that they could be created already during execution. For more details see issue #3423.</p>"},{"location":"using/execution/#legacy-output-file-format","title":"Legacy output file format","text":"<p>There were some backwards incompatible changes to the output file format in Robot Framework 7.0. To make it possible to use new Robot Framework versions with external tools that are not yet updated to support the new format, there is a --legacyoutput option that produces output files that are compatible with Robot Framework 6.x and earlier. Robot Framework itself can process output files both in the old and in the new formats.</p> <p>We hope that external tools are updated soon, but we plan to support this option at least until Robot Framework 8.0. If you encounter tools that are not compatible, please inform the tool developers about changes.</p>"},{"location":"using/execution/#log-file","title":"Log file","text":"<p>Log files contain details about the executed test cases/RPA tasks in HTML format. They have a hierarchical structure showing suite, test case/RPA task and keyword details. Log files are needed nearly every time when test/task results are to be investigated in detail. Even though log files also have statistics, reports are better for getting an higher-level overview.</p> <p>The command line option --log (-l) determines where log files are created. Unless the special value NONE is used, log files are always created and their default name is log.html.</p> <p>TODO: src/ExecutingTestCases/log_passed.png An example of beginning of a log file</p> <p>TODO: src/ExecutingTestCases/log_failed.png An example of a log file with keyword details visible</p> <p>TODO: src/ExecutingTestCases/log_skipped.png An example of a log file with skipped and passed tests</p>"},{"location":"using/execution/#report-file","title":"Report file","text":"<p>Report files contain an overview of the execution results in HTML format. They have statistics based on tags and executed suites, as well as a list of all executed test cases/RPA tasks. When both reports and logs are generated, the report has links to the log file for easy navigation to more detailed information. It is easy to see the overall execution status from report, because its background color is green, if all tests pass and bright red if any test fails. The background can also be yellow, which means that all tests were skipped.</p> <p>The command line option --report (-r) determines where report files are created. Similarly as log files, reports are always created unless NONE is used as a value, and their default name is report.html.</p> <p>TODO: src/ExecutingTestCases/report_passed.png An example report file of successful test execution</p> <p>TODO: src/ExecutingTestCases/report_failed.png An example report file of failed test execution</p> <p>TODO: Yellow file example?</p>"},{"location":"using/execution/#xunit-compatible-result-file","title":"XUnit compatible result file","text":"<p>XUnit result files contain the execution summary in xUnit-compatible XML format. These files can thus be used as an input for external tools that understand xUnit reports. For example, Jenkins continuous integration server supports generating statistics based on xUnit compatible results.</p> <p>\ud83d\udce2 _TIP: Jenkins also has a separate Robot Framework plugin.</p> <p>XUnit output files are not created unless the command line option --xunit (-x) is used explicitly. This option requires a path to the generated xUnit file, relatively to the output directory, as a value.</p> <p>TODO: Include RPA below -  version? <p>XUnit output files were changed pretty heavily in Robot Framework 5.0. They nowadays contain separate  elements for each suite,  elements have timestamp attribute, and suite documentation and metadata is stored as  elements."},{"location":"using/execution/#debug-file","title":"Debug file","text":"<p>Debug files are plain text files which are written during the execution. All messages obtained from libraries are written to them, as well as information about started and ended suites, test cases/RPA tasks and keywords. Debug files can be used for monitoring the test execution. This can be done using, for example, a separate fileviewer.py tool, or in UNIX-like systems, simply with the tail -f command.</p> <p>Debug files are not created unless the command line option --debugfile (-b) is used explicitly.</p>"},{"location":"using/execution/#timestamping-output-files","title":"Timestamping output files","text":"<p>All output files generated by Robot Framework itself can be automatically timestamped with the option --timestampoutputs (-T). When this option is used, a timestamp in the format YYYYMMDD-hhmmss is placed between the extension and the base name of each file. The example below would, for example, create output files such as output-20080604-163225.xml and mylog-20080604-163225.html:</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --timestampoutputs --log mylog.html --report NONE tests.robot\n</code></pre> <p></p>"},{"location":"using/execution/#setting-titles","title":"Setting titles","text":"<p>The default titles for logs and reports are generated by prefixing the name of the top-level suite with Test/Task Log or Test/Task Report. Custom titles can be given from the command line using the options --logtitle and --reporttitle, respectively.</p> \ud83e\udd16 EXAMPLE: <pre><code>robot --logtitle \"Smoke Test Log\" --reporttitle \"Smoke Test Report\" --include smoke my_tests/\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: Prior to Robot Framework 3.1, underscores in the given titles were converted to spaces. Nowadays spaces need to be escaped or quoted as in the example above.</p>"},{"location":"using/execution/#setting-background-colors","title":"Setting background colors","text":"<p>By default the report file has a red background if there are failures, a green background if there are passed tests and possibly some skipped ones, and a yellow background if all tests/tasks are skipped or no tests/tasks have been run. These colors can be customized by using the --reportbackground command line option, which takes two or three colors separated with a colon as an argument:</p> \ud83e\udd16 EXAMPLE: <pre><code>--reportbackground blue:red\n--reportbackground blue:red:orange\n--reportbackground #00E:#E00\n</code></pre> <p></p> <p>If you specify two colors, the first one will be used instead of the default green (pass) color and the second instead of the default red (fail). This allows, for example, using blue instead of green to make backgrounds easier to separate for color blind people.</p> <p>If you specify three colors, the first two have same semantics as earlier and the last one replaces the default yellow (skip) color.</p> <p>The specified colors are used as a value for the body element's background CSS property. The value is used as-is and can be a HTML color name (e.g. red), a hexadecimal value (e.g. #f00 or #ff0000), or an RGB value (e.g. rgb(255,0,0)). The default green, red and yellow colors are specified using hexadecimal values #9e9, #f66 and #fed84f, respectively.</p>"},{"location":"using/execution/#log-levels","title":"Log levels","text":""},{"location":"using/execution/#available-log-levels","title":"Available log levels","text":"<p>Messages in log files can have different log levels. Some of the messages are written by Robot Framework itself, but also executed keywords can log information using different levels. The available log levels are:</p> <ul> <li><code>FAIL</code> Used when a keyword fails. Can be used only by Robot Framework itself.</li> <li><code>WARN</code> Used to display warnings. They shown also in the console and in the Test/Task Execution Errors section in log files, but they do not affect the test case/RPA task status.</li> <li><code>INFO</code> The default level for normal messages. By default, messages below this level are not shown in the log file.</li> <li><code>DEBUG</code> Used for debugging purposes. Useful, for example, for logging what libraries are doing internally. When a keyword fails, a traceback showing where in the code the failure occurred is logged using this level automatically.</li> <li><code>TRACE</code> More detailed debugging level. The keyword arguments and return values are automatically logged using this level.</li> </ul>"},{"location":"using/execution/#setting-log-level","title":"Setting log level","text":"<p>By default, log messages below the INFO level are not logged, but this threshold can be changed from the command line using the --loglevel (-L) option. This option takes any of the available log levels as an argument, and that level becomes the new threshold level. A special value NONE can also be used to disable logging altogether.</p> <p>It is possible to use the --loglevel option also when post-processing outputs with Rebot. This allows, for example, running tests/tasks initially with the TRACE level, and generating smaller log files for normal viewing later with the INFO level. By default all the messages included during execution will be included also with Rebot. Messages ignored during the execution cannot be recovered.</p> <p>Another possibility to change the log level is using the BuiltIn keyword Set Log Level in the input data. It takes the same arguments as the --loglevel option, and it also returns the old level so that it can be restored later, for example, in a test teardown.</p>"},{"location":"using/execution/#visible-log-level","title":"Visible log level","text":"<p>If the log file contains messages at DEBUG or TRACE levels, a visible log level drop down is shown in the upper right corner. This allows users to remove messages below chosen level from the view. This can be useful especially when running test at TRACE level.</p> <p>TODO: src/ExecutingTestCases/visible_log_level.png An example log showing the visible log level drop down</p> <p>By default the drop down will be set at the lowest level in the log file, so that all messages are shown. The default visible log level can be changed using --loglevel option by giving the default after the normal log level separated by a colon:</p> \ud83e\udd16 EXAMPLE: <pre><code>--loglevel DEBUG:INFO\n</code></pre> <p></p> <p>In the above example, tests/tasks are run using level DEBUG, but the default visible level in the log file is INFO.</p>"},{"location":"using/execution/#splitting-logs","title":"Splitting logs","text":"<p>Normally the log file is just a single HTML file. When the amount of the test cases/RPA tasks increases, the size of the file can grow so large that opening it into a browser is inconvenient or even impossible. Hence, it is possible to use the --splitlog option to split parts of the log into external files that are loaded transparently into the browser when needed.</p> <p>The main benefit of splitting logs is that individual log parts are so small that opening and browsing the log file is possible even if the amount of the input data is very large. A small drawback is that the overall size taken by the log file increases.</p> <p>Technically the input data related to each test case/RPA task is saved into a JavaScript file in the same folder as the main log file. These files have names such as log-42.js where log is the base name of the main log file and 42 is an incremented index.</p> <p>\ud83d\udce2 _NOTE: When copying the log files, you need to copy also all the log-*.js files or some information will be missing.</p>"},{"location":"using/execution/#configuring-statistics","title":"Configuring statistics","text":"<p>There are several command line options that can be used to configure and adjust the contents of the Statistics by Tag, Statistics by Suite and Test/Task Details by Tag tables in different output files. All these options work both when executing test cases/RPA tasks and when post-processing outputs.</p>"},{"location":"using/execution/#configuring-displayed-suite-statistics","title":"Configuring displayed suite statistics","text":"<p>When a deeper suite structure is executed, showing all the suite levels in the Statistics by Suite table may make the table somewhat difficult to read. By default all suites are shown, but you can control this with the command line option --suitestatlevel which takes the level of suites to show as an argument:</p> \ud83e\udd16 EXAMPLE: <pre><code>--suitestatlevel 3\n</code></pre> <p></p>"},{"location":"using/execution/#including-and-excluding-tag-statistics","title":"Including and excluding tag statistics","text":"<p>When many tags are used, the Statistics by Tag table can become quite congested. If this happens, the command line options --tagstatinclude and --tagstatexclude can be used to select which tags to display, similarly as --include and --exclude are used to select test cases/RPA tasks:</p> \ud83e\udd16 EXAMPLE: <pre><code>--tagstatinclude some-tag --tagstatinclude another-tag\n--tagstatexclude owner-*\n--tagstatinclude prefix-* --tagstatexclude prefix-13\n</code></pre> <p></p>"},{"location":"using/execution/#generating-combined-tag-statistics","title":"Generating combined tag statistics","text":"<p>The command line option --tagstatcombine can be used to generate aggregate tags that combine statistics from multiple tags. The combined tags are specified using tag patterns where * and ? are supported as wildcards and AND, OR and NOT operators can be used for combining individual tags or patterns together.</p> <p>The following examples illustrate creating combined tag statistics using different patterns, and the figure below shows a snippet of the resulting Statistics by Tag table:</p> \ud83e\udd16 EXAMPLE: <pre><code>--tagstatcombine owner-*\n--tagstatcombine smokeANDmytag\n--tagstatcombine smokeNOTowner-janne*\n</code></pre> <p></p> <p>TODO: src/ExecutingTestCases/tagstatcombine.png Examples of combined tag statistics</p> <p>As the above example illustrates, the name of the added combined statistic is, by default, just the given pattern. If this is not good enough, it is possible to give a custom name after the pattern by separating them with a colon (:):</p> \ud83e\udd16 EXAMPLE: <pre><code>--tagstatcombine \"prio1ORprio2:High priority tests\"   \n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: Prior to Robot Framework 3.1, underscores in the custom name were converted to spaces. Nowadays spaces need to be escaped or quoted as in the example above.</p>"},{"location":"using/execution/#creating-links-from-tag-names","title":"Creating links from tag names","text":"<p>You can add external links to the Statistics by Tag table by using the command line option --tagstatlink. Arguments to this option are given in the format tagname, where tag specifies the tags to assign the link to, link is the link to be created, and name is the name to give to the link.</p> <p>tag may be a single tag, but more commonly a simple pattern where * matches anything and ? matches any single character. When tag is a pattern, the matches to wildcards may be used in link and title with the syntax %N, where \"N\" is the index of the match starting from 1.</p> <p>The following examples illustrate the usage of this option, and the figure below shows a snippet of the resulting Statistics by Tag table when example input data is executed with these options:</p> \ud83e\udd16 EXAMPLE: <pre><code>--tagstatlink mytag:http://www.google.com:Google\n--tagstatlink example-bug-*:http://example.com\n--tagstatlink owner-*:mailto:%1@domain.com?subject=Acceptance_Tests:Send_Mail\n</code></pre> <p></p> <p>TODO: src/ExecutingTestCases/tagstatlink.png Examples of links from tag names</p>"},{"location":"using/execution/#adding-documentation-to-tags","title":"Adding documentation to tags","text":"<p>Tags can be given a documentation with the command line option --tagdoc, which takes an argument in the format tag:doc. tag is the name of the tag to assign the documentation to and it can also be a simple pattern matching multiple tags. doc is the assigned documentation. It can contain simple HTML formatting.</p> <p>The given documentation is shown with matching tags in the Test/Task Details by Tag table, and as a tool tip for these tags in the Statistics by Tag table. If one tag gets multiple documentations, they are combined together and separated with an ampersand.</p> \ud83e\udd16 EXAMPLES: <pre><code>--tagdoc mytag:Example\n--tagdoc \"regression:*See* http://info.html\"\n--tagdoc \"owner-*:Original author\"\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: Prior to Robot Framework 3.1, underscores in the documentation were converted to spaces. Nowadays spaces need to be escaped or quoted as in the examples above.</p>"},{"location":"using/execution/#removing-and-flattening-keywords","title":"Removing and flattening keywords","text":"<p>Most of the content of output files comes from keywords and their log messages. When creating higher level reports, log files are not necessarily needed at all and in that case keywords and their messages just take space unnecessarily. Log files themselves can also grow overly large, especially if they contain FOR loops or other constructs that repeat certain keywords multiple times.</p> <p>In these situations, command line options --removekeywords and --flattenkeywords can be used to dispose or flatten unnecessary keywords. They can be used both when executing test cases/RPA tasks and when post-processing outputs. When used during execution, they only affect the log file, not the XML output file. With rebot they affect both logs and possibly generated new output XML files.</p>"},{"location":"using/execution/#removing-keywords","title":"Removing keywords","text":"<p>The --removekeywords option removes keywords and their messages altogether. It has the following modes of operation, and it can be used multiple times to enable multiple modes. Keywords that contain errors or warnings are not removed except when using the ALL mode.</p> <ul> <li><code>ALL</code> Remove data from all keywords unconditionally.</li> <li><code>PASSED</code> Remove keyword data from passed test cases/RPA tasks. In most cases, log files created using this option contain enough information to investigate possible failures.</li> <li><code>FOR</code> Remove all passed iterations from FOR loops except the last one.</li> <li><code>WHILE</code> Remove all passed iterations from WHILE loops except the last one.</li> <li><code>WUKS</code> Remove all failing keywords inside BuiltIn keyword Wait Until Keyword Succeeds except the last one.</li> <li><code>NAME:&lt;pattern&gt;</code> Remove data from all keywords matching the given pattern regardless the keyword status. The pattern is matched against the full name of the keyword, prefixed with the possible library or resource file name such as MyLibrary.Keyword Name. The pattern is case, space, and underscore insensitive and it supports simple patterns with *, ? and [] as wildcards.</li> <li><code>TAG:&lt;pattern&gt;</code> Remove data from keywords with tags that match the given pattern. Tags are case and space insensitive and they can be specified using tag patterns where *, ? and [] are supported as wildcards and AND, OR and NOT operators can be used for combining individual tags or patterns together. Can be used both with library keyword tags and user keyword tags.</li> </ul> \ud83e\udd16 EXAMPLE: <pre><code>rebot --removekeywords all --output removed.xml output.xml\nrobot --removekeywords passed --removekeywords for tests.robot\nrobot --removekeywords name:HugeKeyword --removekeywords name:resource.* tests.robot\nrobot --removekeywords tag:huge tests.robot\n</code></pre> <p></p> <p>Removing keywords is performed after parsing the output file and generating an internal model based on it. Thus it does not reduce memory usage as much as flattening keywords.</p> <p>Flattening keywords The --flattenkeywords option flattens matching keywords. In practice this means that matching keywords get all log messages from their child keywords, recursively, and child keywords are discarded otherwise. Flattening supports the following modes:</p> <ul> <li><code>FOR</code> Flatten FOR loops fully.</li> <li><code>WHILE</code> Flatten WHILE loops fully.</li> <li><code>ITERATION</code> Flatten individual FOR and WHILE loop iterations.</li> <li><code>FORITEM</code> Deprecated alias for ITERATION.</li> <li><code>NAME:&lt;pattern&gt;</code> Flatten keywords matching the given pattern. Pattern matching rules are same as when removing keywords using the NAME: mode. <li><code>TAG:&lt;pattern&gt;</code> Flatten keywords with tags matching the given pattern. Pattern matching rules are same as when removing keywords using the TAG: mode. \ud83e\udd16 EXAMPLES: <pre><code>robot --flattenkeywords name:HugeKeyword --flattenkeywords name:resource.* tests.robot\nrebot --flattenkeywords foritem --output flattened.xml original.xml\n</code></pre> <p></p> <p>Flattening keywords is performed already when the output file is parsed initially. This can save a significant amount of memory especially with deeply nested keyword structures.</p>"},{"location":"using/execution/#flattening-keyword-during-execution-time","title":"Flattening keyword during execution time","text":"<p>Starting from Robot Framework 6.1, it is possible to enable the keyword flattening during the execution time. This can be done only on an user keyword level by defining the reserved tag robot:flatten as a keyword tag. Using this tag will work similarly as the command line option described in the previous chapter, e.g. all content except for log messages is removed from under the keyword having the tag. One important difference is that in this case, the removed content is not written to the output file at all, and thus cannot be accessed at a later time.</p> \ud83e\udd16 SOME EXAMPLES: <pre><code>*** Keywords ***\nFlattening affects this keyword and all it's children\n    [Tags]    robot:flatten\n    Log    something\n    FOR     ${i}     IN RANGE     2\n         Log    The message is preserved but for loop iteration is not\n    END\n\n*** Settings ***\n# Flatten content of all uer keywords\nKeyword Tags    robot:flatten\n</code></pre> <p></p>"},{"location":"using/execution/#automatically-expanding-keywords","title":"Automatically expanding keywords","text":"<p>Keywords which have passed are closed in the log file by default. Thus information they contain is not visible unless you expand them. If certain keywords have important information that should be visible when the log file is opened, you can use the --expandkeywords option to set keywords automatically expanded in log file similar to failed keywords. Expanding supports the following modes:</p> <ul> <li><code>NAME:&lt;pattern&gt;</code> Expand keywords matching the given pattern. Pattern matching rules are same as when removing keywords using the NAME: mode. <li><code>TAG:&lt;pattern&gt;</code> Expand keywords with tags matching the given pattern. Pattern matching rules are same as when removing keywords using the TAG: mode. If you need to expand keywords matching different names or patterns, you can use the --expandkeywords multiple times. \ud83e\udd16 EXAMPLES: <pre><code>robot --expandkeywords name:SeleniumLibrary.CapturePageScreenshot tests.robot\nrebot --expandkeywords tag:example --expandkeywords tag:another output.xml\n</code></pre> <p></p> <p>\ud83d\udce2 _NOTE: The --expandkeywords option is new in Robot Framework 3.2.</p>"},{"location":"using/execution/#setting-start-and-end-time-of-execution","title":"Setting start and end time of execution","text":"<p>When combining outputs using Rebot, it is possible to set the start and end time of the combined test suite/RPA task using the options --starttime and --endtime, respectively. This is convenient, because by default, combined suites do not have these values. When both the start and end time are given, the elapsed time is also calculated based on them. Otherwise the elapsed time is obtained by adding the elapsed times of the child test suites together.</p> <p>It is also possible to use the above-mentioned options to set start and end times for a single suite when using Rebot. Using these options with a single output always affects the elapsed time of the suite.</p> <p>Times must be given as timestamps in the format YYYY-MM-DD hhss.mil, where all separators are optional and the parts from milliseconds to hours can be omitted. For example, 2008-06-11 17:59:20.495 is equivalent both to 20080611-175920.495 and 20080611175920495, and also mere 20080611 would work.</p> \ud83e\udd16 EXAMPLES: <pre><code>rebot --starttime 20080611-17:59:20.495 output1.xml output2.xml\nrebot --starttime 20080611-175920 --endtime 20080611-180242 *.xml\nrebot --starttime 20110302-1317 --endtime 20110302-11418 myoutput.xml\n</code></pre> <p></p>"},{"location":"using/execution/#limiting-error-message-length-in-reports","title":"Limiting error message length in reports","text":"<p>If a test case/RPA task fails and has a long error message, the message shown within reports is automatically cut from the middle to keep reports easier to read. By default messages longer than 40 lines are cut, but that can be configured by using the --maxerrorlines command line option. The minimum value for this option is 10, and it is also possible to use a special value NONE to show the full message.</p> <p>Full error messages are always visible in log files as messages of the failed keywords.</p> <p>\ud83d\udce2 _NOTE: The --maxerrorlines option is new in Robot Framework 3.1.</p>"},{"location":"using/execution/#programmatic-modification-of-results","title":"Programmatic modification of results","text":"<p>If the provided built-in features to modify results are not enough, Robot Framework makes it possible to perform custom modifications programmatically. This is accomplished by creating a model modifier and activating it using the --prerebotmodifier option.</p> <p>This functionality works nearly the same as programmatic modification of input data which can be enabled with the --prerunmodifier option. The obvious difference is that this time modifiers operate with the result model, not the running model. For example, the following modifier marks all passed tests that have taken more time than allowed as failed:</p> \ud83e\udd16 EXAMPLE: <pre><code> from robot.api import SuiteVisitor\n\n\n class ExecutionTimeChecker(SuiteVisitor):\n\n     def __init__(self, max_seconds: float):\n         self.max_milliseconds = max_seconds * 1000\n\n     def visit_test(self, test):\n         if test.status == 'PASS' and test.elapsedtime &gt; self.max_milliseconds:\n             test.status = 'FAIL'\n             test.message = 'Test execution took too long.'\n</code></pre> <p></p> <p>If the above modifier would be in file ExecutionTimeChecker.py, it could be used, for example, similar to this:</p> \ud83e\udd16 EXAMPLE: <pre><code># Specify modifier as a path when running tests. Maximum time is 42 seconds.\nrobot --prerebotmodifier path/to/ExecutionTimeChecker.py:42 tests.robot\n\n# Specify modifier as a name when using Rebot. Maximum time is 3.14 seconds.\n# ExecutionTimeChecker.py must be in the module search path.\nrebot --prerebotmodifier ExecutionTimeChecker:3.14 output.xml\n</code></pre> <p></p> <p>If more than one model modifier is needed, they can be specified by using the --prerebotmodifier option multiple times. When executing tests, it is possible to use --prerunmodifier and --prerebotmodifier options together.</p> <p>\ud83d\udce2 _NOTE: Argument conversion based on type hints like max_seconds: float in the above example is new in Robot Framework 4.0 and requires Python 3.</p>"},{"location":"using/execution/#system-log","title":"System log","text":"<p>Robot Framework has its own plain-text system log where it writes information about</p> <ul> <li>Processed and skipped input data files</li> <li>Imported test libraries, resource files and variable files</li> <li>Executed test suites and test cases</li> <li>Created outputs</li> </ul> <p>Normally users never need this information, but it can be useful when investigating problems with test libraries or Robot Framework itself. A system log is not created by default, but it can be enabled by setting the environment variable ROBOT_SYSLOG_FILE so that it contains a path to the selected file.</p> <p>A system log has the same log levels as a normal log file, with the exception that instead of FAIL it has the ERROR level. The threshold level to use can be altered using the ROBOT_SYSLOG_LEVEL environment variable like shown in the example below. Possible unexpected errors and warnings are written into the system log in addition to the console and the normal log file.</p> \ud83e\udd16 EXAMPLE: <pre><code>#!/bin/bash\n\nexport ROBOT_SYSLOG_FILE=/tmp/syslog.txt\nexport ROBOT_SYSLOG_LEVEL=DEBUG\n\nrobot --name Syslog_example path/to/tests\n</code></pre> <p></p>"}]}